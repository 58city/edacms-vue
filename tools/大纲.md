## 第一部分 面向对象

### 1、面向对象基础

**面向对象的应用：**

react

vue

**对象的构成：**

对象=数据+操作

数据==>属性（变量）、状态、数据

操作==>方法（过程）、函数

**类的一些概念：**

类class：蓝图、设计图

实例instance==>对象：由类创建的（new）,有功能的

成员member：包括的东西（属性+方法），实例成员、静态/类成员

**抽象：**

1.设计类、设计程序抽离一些公共的特征

2.只提供方法，不提供实现（抽象类）

#### 1）理解面向对象思想

**封装**

- 目的1：保护成员不被乱搞，易维护，易读，不易出错
- 目的2：数据隐藏，只能通过提供的方法去修改
- 目的3：强制访问权限
- 目的3：便于项目协作，你封装的方法别人只要能用就可以了，不必关注里面的细节

**继承**

- 目的1：重用代码
- 目的2：修改父类，但是不能直接修改
  - 多重继承：一个类需要使用多个父类的功能（js不支持，Java不支持，c++支持）
  - 抽象类

**多态**

- 抽象
- 简化问题

**面向对象的目的总的来说就是为了：**

- 重用代码
- 防止犯错
- 团队协同

#### 2）掌握类的写法

- 旧版--ES5

  构造函数和类傻傻分不清楚

  ```js
  function A(){
      console.log('被创建了')
      // 添加属性
      this.name='ssl'
      this.age=18
  }
  # 添加方法，和构造函数分离很不美
  A.prototype.show=function(){
      console.log(this.name+this.age)
  }
  var a=new A()
  ```

  > 写法相比ES6来说比较凌乱

- 新版--ES6

  构造函数和类泾渭分明

  ```js
  class A{
      constructor(){
          console.log('被创建了')
          // 添加属性
          this.name='ssl'
      	this.age=18
      }
      // 添加方法
  	show(){
      	console.log(this.name+this.age)
  	}
  }
  let a=new A()
  ```

  > 这里的类成员方法不能加function，因为这是一个方法而不是一个函数（语法规定）

- 面向对象的本质

  ```js
  class A{
      constructor(name,age){
          console.log('被创建了')
          // 添加属性
          this.name='ssl'
      	this.age=18
      }
      // 添加方法
  	show(){
      	console.log(this.name+this.age)
  	}
  }
  let a=new A('ssl',30)
  let b=new B('wyy',30)
  ```

  vs：本质上是一个空间，把公共的代码组织在一起，方便重用（只用一次下面的写法就可以了）

  ```
  let a_name='ssl'
  let a_age=30
  
  let b_name='wyy'
  let b_age=30
  
  function a_show(){
      console.log(a_name+a_age)
  }
  
  function b_show(){
      console.log(b_name+b_age)
  }
  ```

#### 3）类型检测

类在实例化时需要传参，有时需要判断数据的类型，根据不同的类型做出不同的处理，那么如何检测呢？

- typeof：只能检测基本类型的数据，引用类型的检测一律返回Object

- instanceof：检测一个实例是不是属于某一个类，但是除了隶属于它的父类外还隶属于它父类的父类

  兼容性问题？？？？

- constructor：返回实例的构造器---可以间接用于精确检测一个实例是不是属于一个唯一父类

- Object.prototype.toString.call([1,2])===>"[object Array]"

在dom中的应用：

```js
let oDiv=document.getElementById('div1')
alert(oDiv.constructor == HTMLDivElement)
alert(oDiv instanceof HTMLElement)
```

#### 4）使用类实现音乐列表

先自上而下分析，提炼一些功能==》方法和属性

- 功能：
  - 修改标题
  - 设置列表数据
  - 重新渲染
- 方法：
  - setTitle()/getTitle()
  - setData()/getData()
- 数据：
  - title
  - data

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="./css/initialize.css">
  <link rel="stylesheet" href="./css/style.css">
  <title>智能社</title>
  <script src="js/assert.js" charset="utf-8"></script>
</head>

<body>
  <div class="hot-host"></div>
  <script>
    class HotList {
      //parent自动判断
      constructor(parent, title='', data=[]) {
        assert(parent, 'parent必须有');
        assert(typeof title=='string', 'title不是一个字符串');
        assert(data instanceof Array, 'data必须是一个数组');
        this.parent=parent;
        this.title=title;
        this.data=data;
        this.render();
      }
      setTitle(title){
        this.title=title;
        this.render();
      }
      getTitle(){
        return this.title;
      }
      setData(data){
        this.data=data;
        this.render();
      }
      getData(){
        return this.data;
      }
      render(){
        let div=document.createElement('div');
        div.className='v-hd';
        div.innerHTML=this.title;
        let ul=document.createElement('ul');
        ul.className='user-list';
        let arr=[];
        this.data.forEach(data=>{
          arr.push(`
            <li class="row">
              <a href="${data.href}" class="cver">
                <img src="${data.avatar}" alt="">
              </a>
              <div class="info">
                <p class="row aic">
                  <a href="${data.href}" class="nm-icn">${data.name}</a>
                  ${data.vip?'<img src="./img/vip.png" alt="">':''}
                </p>
                <p class="label">${data.title}</p>
              </div>
            </li>
          `);
        });
        ul.innerHTML=arr.join('');
        this.parent.innerHTML='';
        this.parent.appendChild(div);
        this.parent.appendChild(ul);
      }
    }
    let hot=document.querySelector('.hot-host');
    let list=new HotList(hot, '热门主播', [
      {
        name: 'blue',
        href: 'http://www.zhinengshe.com/',
        avatar: 'img/1407374893913311.jpg',
        vip: false,
        title: '打杂的'
      },
      {
        name: 'blue',
        href: 'http://www.zhinengshe.com/',
        avatar: 'img/1407374893913311.jpg',
        vip: false,
        title: '打杂的'
      },
      {
        name: 'blue',
        href: 'http://www.zhinengshe.com/',
        avatar: 'img/1407374893913311.jpg',
        vip: false,
        title: '打杂的'
      }
    ]);
  </script>
</body>
</html>

```

> 遇到问题：
>
> 1.传参错误，报错位置不准确--解决方法：检测参数类型，抛出错误（封装断言库）
>
> 2.每次实例化或更新数据的时候视图不会自动渲染--解决方法：在构造、setTitle、setData中调用render
>
> 3.类中传入的数据为公用状态，任何人都可以随意修改（不受保护）
>
> 4.每次更新数据都要重新渲染，浪费性能--解决方法：虚拟DOM

#### 5）原型

- 长啥样
- 原理
- 干啥的
  - 共享方法
  - 修补内置类方法：如低版本浏览器不支持的数组map方法
- 作业
  - 数组方法的polyfill
    - filter/map/reduce/unique
    - Array.from
  - 字符串方法的polyfill
    - String.from
  - 豆瓣弹出层
    - 点击频道名称，豆瓣弹出层
    - 点击页面任意位置，弹出层消失
    - 弹出层中的数据要是活的
    - 弹出层选择后，频道名称变了

#### 6）this

谁在调用？

- 普通函数中的this==>window对象，全局的东西都属于window,ES5严格模式下省略winow.则为undefined
- 对象中的方法里的this==>当前对象
- 事件中的this==>绑定该事件的DOM对象
- 定时器中的this==>window对象，无论是不是严格模式

为什么要有this? 为了帮助我们使用当前实例对象！this==当前实例对象

- 字面量对象中的方法里，如果要引用当前对象如果没有this就要使用对象名称，使用多了不易维护
- ES6中的class类里的方法要调用构造里的属性，如果没有this就要使用实例的名称，但是每个实例名称不一样

为什么this这么乱？为了让js能更简单易用

- 其他语言中函数不能独立存在，必须要属于某一个类，所以他们的this就是指向当前对象
- 而js中可以存在于很多不同的地方，比如：独立存在，属于对象，属于事件...

操作this（改变指向）

- 函数方法：函数本身也是一个对象，也存在方法

  ```js
  function show(){ }
  console.log(show.constructor)  ==> Function
  ```

  > call和apply
  >
  > ```js
  > # show.call() === show()，只不过通过call我们可以额外传递一个参数，改变show内部this的指向
  > # 第一个参数指定this指向
  > # 第二个参数为show要接收的参数
  > shiw.call(12,param1,param2)
  > # call和apply唯一的不同是apply为函数接收的实际参数为一个数组
  > ```
  >
  > bind
  >
  > ```js
  > # 和call以及apply不同，bind会生成一个没有执行的新函数（修改了this）
  > # call以及apply会立即执行
  > function show(){
  > 	alert（this）
  > }
  > let show2=show.bind(12)
  > document.onclick=show.bind(Array)
  > 
  > ```

- 箭头函数

  - 箭头函数内部的this永远跟箭头函数外部一致

  - 箭头函数相当于自带一个bind(this)

  - 扩展：

    - 动态获取函数名称`argument.callee.name`，es5严格模式下无效

    - 类的成员方法可以是箭头函数吗？不能

      class类直接报错，字面量对象中方法如果使用箭头函数this指向window

- 传统方法

### 2、面向对象与继承

#### 1）面向对象的精华

js中继承非常常见，比如：

```js
arr instanceof Array
arr instanceof Object

class Person{
    
}
let p=new Person()
p instanceof Person
p instanceof Object

let oTxt=document.getElementById('txt1')
oTxt.constructor//function HTMLInputElement
oTxt instanceof HTMLInputElement
oTxt instanceof HTMLElement
oTxt instanceof Element
oTxt instanceof Node
oTxt instanceof Object
```

> js中所有的类最终都继承自Object

#### 2）继承的目的

- 为了让类有一个清晰的层次--阅读方便、公共操作/属性的划分重用

  ![1574782896076](D:\工作\课程\01.初级\阶段3：JavaScript高级特性\assets\1574782896076.png)

- 功能得到重用（属性、方法）

- 使用多态简化程序???????????????????????????????????????????????????

#### 3）适用场景

- 拥有明确的父子关系
- 子类功能能够完全覆盖父类：子类>=父类
  - DataPicker extends Component
  - ImageFile extends File
  - User extends File

#### 4）概念

- 父类：被继承的类（基类、超类）

- 子类：通过继承出来的新的类（派生类、衍生类）

- 抽象类：无法被实例化使用，只能作为父类被继承，有一些公共的功能

  js本身不支持抽象类，只是一个概念

#### 5）继承的写法

- ES5：乱、麻烦、不统一

  ```js
  function A(user){
      this.user=user
  }
  A.prototype.run=function(){
      console.log(this.user)
  }
  
  function B(user,age){
      # 继承父类构造中的属性
      A.call(this,user)
      this.age=age
  }
  # 继承父类原型中的方法，下面这种方式不好因为父类和子类使用一个原型，导致向子类添加方法，父类也有了
  # B.prototype=A.prototype
  B.prototype=new A
  # 需要重置一下B的constructor指向
  B.prototype.constructor=B
  B.prototype.show=function(){
      console.log(this.age)
  }
  
  
  let b=new B('SSL',20)
  b.run()
  ```

  > 问题：

- ES6：统一、简洁

  ```js
  class A{
      constructor(user){
          this.user=user
      }
      run(){
          console.log(this.user)
      }
  }
  # 已经有了父类的所有属性和方法
  class B extends A{
  	# 内部会默认创建一个constructor继承父类所有的属性和方法
  }
  # 扩展子类自己的属性和方法
  class B extends A{
      constructor(user,age){
          # super是一个关键字代表父类，并不是变量，随不能比较super==A
          super(user)
          # 扩展自己的属性，必须写在super的后面
          this.age=age
      }
      show(){
          console.log(this.age)
      }
  }
  
  let b=new B('SSL',20)
  b.run()
  ```

#### 6）原型链

    实例.属性==>先在实例中查找
               没有去类的原型
    
                       没有再去父类找==>先在父类实例中查找
                                      没有再去父类的原型

#### 7）多重继承

一个类是由多个类派生出来的，但是js不支持多重继承，替代方案--组合

#### 8）例子：员工管理

```html
<script>
    class Staff{
        constructor(name,depart,baseSalary){
            this.name=name
            this.depart=depart
            this.baseSalary=baseSalary
        }
        salary(){
            if(this.baseSalary<=5000){
                return this.baseSalary-800
            }
            if(this.baseSalary<=8000){
                return this.baseSalary-1000
            }
            return this.baseSalary-500
        }
    }
    class Coder extends Staff{
        constructor(name,depart,baseSalary,codeType){
            super(name,depart,baseSalary)
            this.codeType=codeType
        }
        // 重写父类salary方法
        salary(){
            // 如何调用父类的salary?直接this.salary会调用自己的salary，导致栈溢出
            // super的作用：
            // 1.父类的构造器
            // 2.父类方法的存储空间
            return super.salary()*1.1
        }
    }

    class Designer extends Staff{
        constructor(name,depart,baseSalary,tools){
            super(name,depart,baseSalary)
            this.tools=tools
        }
        // 重写父类salary方法
        salary(){
            return super.salary()+800
        }
    }

    let staffs=[
        new Coder('zhangsan',18,5000,'js'),
        new Designer('lisi',16,3000,'ps')
    ]
    // 多态： 
    //     同一个方法，在不同的类的实例下的表现也不一样
    // 条件： 
    //     这些不同的类，要直接或间接的继承自同一个父类
    //     这些不同的类，要重写父类的同一个方法，重写时各自逻辑不同
    // 作用： 
    //     不用管实例的具体类型（属于哪个类），直接使用该方法即可（即使实例中没有这个方法，但父类有）
    //     而不用在循环时判断实例类型，并对工资根据类型进行处理，因为各自在重写的salary方法中已经有了
    //     从而简化代码
    let sum=0
    staffs.forEach(staff=>{
        sum+=staff.salary()
    })
</script>
```

#### 9）例子：组件渲染

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="utf-8">
    <title></title>
    <style media="screen">
        .dialog {width:400px; height:300px; margin:10px auto; border:1px solid black;}
    </style>
</head>
<body>
    <div id="div1">
        <div class="">adfasdfsad</div>
        <Cmp1 click="fn"></Cmp1>
        <Cmp1></Cmp1>
        <UserLogin></UserLogin>
    </div>
    <script>
        //html元素->组件
        function Vue(options){
            //1.root搞定
            let root=null;
            if(typeof options.root=='string'){
                root=document.querySelector(options.root);
                if(!root){
                    throw new Error(`can't found ${options.root}`);
                }
            }else if(options.root instanceof HTMLElement){
                root=options.root;
            }else{
                throw new Error('root invaild');
            }
            //2.找出所有自定义元素
            let elements=root.getElementsByTagName('*');
            Array.from(elements).forEach(element=>{
                if(element.constructor==HTMLUnknownElement){
                    for(let cmpName in options.components){
                        if(cmpName.toLowerCase()==element.tagName.toLowerCase()){
                            let CmpCls=options.components[cmpName];
                            let cmp=new CmpCls();
                            let res=cmp.render();
                            element.parentNode.replaceChild(res, element);
                        }
                    }
                }
            });
        }
        //抽象的
        class Component{
          render(){
            throw new Error(`render is required`);
          }
        }
        class Cmp1 extends Component{
            render(){
                let div=document.createElement('div');
                div.innerHTML='我是cmp1';
                return div;
            }
        }
        class UserLogin extends Component{
            render(){
                let div=document.createElement('div');
                div.className="dialog";
                div.innerHTML='dsfasdfsd';
                return div;
            }
        }
        Vue({
            root: '#div1',
            components: {
                Cmp1, UserLogin
            },
            methods: {
                fn(){
                    alert('a');
                }
            }
        });
    </script>
</body>
</html>
```

> 思路：
>
> 1.设计render函数
>
> 2.获取组件所在的根元素
>
> 3.找出所有的自定义组件元素
>
> 4.根据找到的自定义组件元素的名称，实例化组件对应的类，并调用对应类的渲染方法
>
> DOM操作慢的原因：
>
> 1.臃肿
>
> 2.重绘--图形输出
>
> 3.重排--元素大小位置改变会引起重拍（渲染回流）

### 3、可响应对象

#### 1）HOC高阶类

##### 基本原理

父类用子类的方法或属性

```html
<script>
	class A{
    	constructor(){
        	this.name='blue';
		}
    	show(){
        	alert(this.name);
        	alert(this.age);    //?
    	}
    }
    # 第一个弹框blue，第二个弹框undefined
    let a=new A();
    a.show();
    
    class B extends A{
    	constructor(){
        	super();
        	this.age=18;
      	}
    }
    # 第一个弹框blue，第二个弹框18
    let b=new B();
    b.show();
</script>
```

##### 应用场景

多个类之间数据共享

```js
class Store{
    constructor(){
        this._state={};
    }
    get(key){
        if(key in this._state){
            return this._state[key];
        }else{
            throw new Error(`${key} is not defined`);
        }
    }
    set(key, val){
        this._state[key]=val;
    }
    connect(cls){
        let store=this;
        return class extends cls{
            constructor(...args){
                super(...args);
                this.get=store.get.bind(store);
                this.set=store.set.bind(store);
                // this.get=store.get;
                // this.set=store.set;
            }
        }
    }
}
let store=new Store();

const A=store.connect(class {
  	constructor(){ }
  	getA(){
    	console.log(this.get('a'));
  	}
});

const B=store.connect(class {
  	constructor(){ }
  	setA(){
    	this.set('a', 12);
  	}
});

let a=new A();
let b=new B();

b.setA();
a.getA();
```

#### 2）可响应对象

##### 访问器--get/set 

ECMAScript 5新增特性,Getter 和 Setter 允许您定义对象访问器（被计算的属性）

```js
class A{
    constructor(){
        this._count=12
    }
    get count(){
        return this._count
    }
    set count(val){
        if(typeof val != 'number'){
            throw new Error('val must be a number')
        }
        this._count=val
    }
}

let a=new A()
console.log(a.count)
```

**音乐列表完善：**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="./css/initialize.css">
  <link rel="stylesheet" href="./css/style.css">
  <title>智能社</title>
  <script src="js/assert.js" charset="utf-8"></script>
</head>

<body>
  <div class="hot-host"></div>
  <script>
    class HotList {
      //parent自动判断
      constructor(parent, title='', data=[]) {
        assert(parent, 'parent必须有');
        assert(typeof title=='string', 'title不是一个字符串');
        assert(data instanceof Array, 'data必须是一个数组');
        this.parent=parent;
        this._title=title;
        this.data=data;
        this.render();
      }
      set title(title){
        this._title=title;
        this.render();
      }
      get title(){
        return this._title;
      }
      setData(data){
        this.data=data;
        this.render();
      }
      getData(){
        return this.data;
      }
      render(){
        let div=document.createElement('div');
        div.className='v-hd';
        div.innerHTML=this.title;
        let ul=document.createElement('ul');
        ul.className='user-list';
        let arr=[];
        this.data.forEach(data=>{
          arr.push(`
            <li class="row">
              <a href="${data.href}" class="cver">
                <img src="${data.avatar}" alt="">
              </a>
              <div class="info">
                <p class="row aic">
                  <a href="${data.href}" class="nm-icn">${data.name}</a>
                  ${data.vip?'<img src="./img/vip.png" alt="">':''}
                </p>
                <p class="label">${data.title}</p>
              </div>
            </li>
          `);
        });
        ul.innerHTML=arr.join('');
        this.parent.innerHTML='';
        this.parent.appendChild(div);
        this.parent.appendChild(ul);
      }
    }
    let hot=document.querySelector('.hot-host');
    let list=new HotList(hot, '热门主播', [
      {
        name: 'blue',
        href: 'http://www.zhinengshe.com/',
        avatar: 'img/1407374893913311.jpg',
        vip: false,
        title: '打杂的'
      },
      {
        name: 'blue',
        href: 'http://www.zhinengshe.com/',
        avatar: 'img/1407374893913311.jpg',
        vip: false,
        title: '打杂的'
      },
      {
        name: 'blue',
        href: 'http://www.zhinengshe.com/',
        avatar: 'img/1407374893913311.jpg',
        vip: false,
        title: '打杂的'
      }
    ]);
  </script>
</body>
</html>
```

##### defineProperpty

```js
let A={
    _count:12
}
Object.defineProperty(A,'count',{
    get(){
        return A._count
    },
    set(val){
        if(typeof val != 'number'){
            throw new Error('val must be a number')
        }
        A._count=val
    },
    configurable:true
})
console.log(A.count)
A.count=122
console.log(A.count)
```

**vue的核心**

```js
let json={ }

class App{
    constructor(opts){
        let data=opts.data()
        # 把数据定义到一个公共的json上
        Object.defineProperty(json,'a',{
            configurable:true,
            get(){
                return data.a
            },
            set(val){
                data.a=val
            }
        })
    }
}

let app=new App({
    root:'#div',
    data(){
        return {
            a:12,
            b:5
        }
    }
})

console.log(json.a)
json.a=188
console.log(json.a)
```

> 上面这种方式，数据操作极其别扭，在vue中data数据可以通过实例直接访问，形似`app.a`

```js
class App{
    constructor(opts){
        let data=opts.data()
        # 把数据定义到实例this上
        for(let name in data){
            Object.defineProperty(this,name,{
                configurable:true,
                get(){
                    return data[name]
                },
                set(val){
                    console.log('有人设置了'+name+'数据')
                    this.render()
                    data[name]=val
                }
            })
        }
        # 解决触发两次的bug
        this._updated=false
    }
    # 当数据为数组或对象时，改变数组的某个元素或对象的某个属性，defineProperty的set不会触发
    # 需要$set进行修补，但是有人会app.$set(app,a,123),会触发两次‘重新渲染视图吧’
    $set(obj,key,val){
        this._updated=false
        // 假如改变的是普通属性，则进入set里面的render,this._updated变为true
        obj[key]=val
        if(this._updated==false){
            this.render()
        }
    }
    render(){
        console.log('重新渲染视图吧')
        this._updated=true
    }
}

let app=new App({
    root:'#div',
    # 为什么不直接使用json，而是搞一个函数返回一个json
    # 因为如果直接使用json，容易导致多个实例公用一个json，进而导致多个实例数据共享
    data(){
        return {
            a:12,
            b:5
        }
    }
})

console.log(app.a)
app.a=188
console.log(app.a)
```

**完善音乐列表**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="./css/initialize.css">
  <link rel="stylesheet" href="./css/style.css">
  <title>智能社</title>
  <script src="js/assert.js" charset="utf-8"></script>
</head>

<body>
  <div class="hot-host"></div>
  <script>
    class HotList {
      constructor(opts) {
        assert(opts, 'opts必须有');
        this._root=this._getRoot(opts);    
        this._defineData(opts);    
        this._updated=false
        this.render();
      }
      _getRoot(opts){
		assert(opts.root,'root不能为空') 
        if(typeof opts.root=='string'){
          let root=document.querySelector(opts.root) 
          assert(root,`找不到：${opts.root}`)
          return root
        }else if(opts.root instanceof HTMLElement){
		  return opts.root
        }else{
          assert(false,'root不合法')
        }
      }
      _defineData(opts){
        assert(opts.data,'data不能为空') 
        assert(typeof opts.data=='function','data必须为函数')
        
        let data=opts.data()
        assert(data,'data必须有返回值') 
        assert(typeof data=='object','data必须为object')
          
        for(let name in data){
          Object.defineProperty(this,name,{
            configurable:true,
            get(){
              return data[name]    
            },
            set(val){
              data[name]=val    
            }
          })
        }
      }
      $set(obj,key,val){
        this._updated=false
        obj[key]=val
        if(this._updated==false){
          this.render()     
        }
      }
      render(){
        let div=document.createElement('div');
        div.className='v-hd';
        div.innerHTML=this.title;
        let ul=document.createElement('ul');
        ul.className='user-list';
        let arr=[];
        this.data.forEach(data=>{
          arr.push(`
            <li class="row">
              <a href="${data.href}" class="cver">
                <img src="${data.avatar}" alt="">
              </a>
              <div class="info">
                <p class="row aic">
                  <a href="${data.href}" class="nm-icn">${data.name}</a>
                  ${data.vip?'<img src="./img/vip.png" alt="">':''}
                </p>
                <p class="label">${data.title}</p>
              </div>
            </li>
          `);
        });
        ul.innerHTML=arr.join('');
        this._root.innerHTML='';
        this._root.appendChild(div);
        this._root.appendChild(ul);
        this._updated=true;
      }
    }
    let list=new HotList({
		root:'.hot-host',
        data(){
            return {
                title:'热门主播',
                data:[{
                    name: 'blue',
                    href: 'http://www.zhinengshe.com/',
                    avatar: 'img/1407374893913311.jpg',
                    vip: false,
                    title: '打杂的'
                },{
                	name: 'blue',
                    href: 'http://www.zhinengshe.com/',
                	avatar: 'img/1407374893913311.jpg',
                	vip: false,
                	title: '打杂的'
            	}]
            }
        }
    })
  </script>
</body>
</html>
```

##### Proxy

Observe(废弃) ==> Proxy

**包装对象**

```js
//真实数据
let _data={
    a: 12,
    arr: [1,2,3],
    json: {a: 12, b: 5}
};

let p=new Proxy(_data, {
    has(data, name){    //in
        if(name in data){
            return true;
        }else{
            return false;
        }
    },
    get(data, name){  //获取
        if(name in data){
            return data[name];
        }else{
            throw new Error(`${name} is not defined`);
        }
    },
    set(data, name, val){    //设置
        console.log('set');
        data[name]=val;
    },
    deleteProperty(data, name){   //处理delete
        if(name in data){
            return delete data[name];
        }else{
            throw new Error(`${name} is not defined`);
        }
    }
});

console.log(p.a)
p.a=24
console.log(p.arr[0])
p.arr[0]=11
```

**包装函数**

```js
let _data=function (a, b, c){
    console.log(a+b+c);
};
let p=new Proxy(_data, {
    apply(fn, thisValue, args){
        if(args.length!=3){
            throw new Error('argument length must be 3');
        }else{
            fn(...args);
        }
    }
});
p(23,5,6);
```

**包装数组**

```js
let _data=[1,2,3];
let p=new Proxy(_data, {
    get(data, name){
        console.log('get');
        return data[name];
    },
    set(data, name, val){
        console.log('set');
        data[name]=val;
    }
});

console.log(p[0])
p[0]=100
console.log(p[0])
p[3]=200
# push也会走set但是报错
p.push(123)
```

> 报错原因：push操作会触发两次set，第一次data[3]=123，第二次data[length]=4
> 而第二次为数组非法操作，所以会停止第二次的set，并报错
>
> 解决方法：set函数中return true即可，但是set会触发多次
>
> 假如为shift操作（删除第一个），会触发（arr.length-1）*2+1次，因为位置每变化一次都会触发

```js
let arr=new Proxy([12,5,8,9,23,88,32], {
    set(arr, name, val){
        arr[name]=val;
        render();
        return true;
    }
});

let timer=null;
function render(){
    clearTimeout(timer);
    timer=setTimeout(function (){
        console.log('render');
    }, 0);
}
```

**包装类**

```js
class A{ }
let p=new Proxy(A, {
    //不叫constructor
    construct(fn, args){
        console.log('new', fn, args);
        return {};
    }
});
new p(1,2,3);
```

**响应类**

监听类的属性的变化

```js
class A{
    render(){
        console.log('渲染');
    }
}
let a=new Proxy(new A(), {
    set(obj, name, val){
        obj[name]=val;
        obj.render();
    }
});
a.name='blue';
```

> 上面做法也可以但是有些繁琐

```js
let A=new Proxy(class {
    render(){
        console.log('渲染');
    }
}, {
    construct(cls, args){
        let obj=new cls();
        return new Proxy(obj, {
            set(data, name, val){
                data[name]=val;
                obj.render();
            }
        });
    }
});
let a=new A();
```

**例子：数据改变，重新渲染**

```js
class Cmp{
    constructor(name){
        this.name=name;
        this.el=document.createElement('div');
        this.el.className='box';
        document.body.appendChild(this.el);
        this.render();
    }
    render(){
        this.el.innerHTML=this.name;
    }
}

let cmp=new Proxy(new Cmp('blue'), {
    set(obj, name, val){
        obj[name]=val;
        obj.render();
    }
});
```

> 上面使用起来比较复杂

```js
// 包装类
// 拦截new操作
const Cmp=new Proxy(class {
    constructor(name){
        this.name=name;
        this.el=document.createElement('div');
        this.el.className='box';
        document.body.appendChild(this.el);
        this.render();
    }
    render(){
        this.el.innerHTML=this.name;
    }
}, {
    construct(cls, args){
        let obj=new cls(...args);
        // 拦截set操作
        return new Proxy(obj, {
            set(obj, name, val){
                obj[name]=val;
                obj.render(); 
            }
        });
    }
});
//接收返回的可响应类
let cmp=new Cmp('blue');
```

**例子：完善音乐列表**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="./css/initialize.css">
  <link rel="stylesheet" href="./css/style.css">
  <title>智能社</title>
  <script src="js/assert.js" charset="utf-8"></script>
</head>

<body>
  <div class="hot-host"></div>
  <script>
    new Proxy(class HotList {
      constructor(opts) {
        assert(opts, 'opts必须有');
        this._root=this._getRoot(opts);
      }
      _getRoot(opts){
		assert(opts.root,'root不能为空') 
        if(typeof opts.root=='string'){
          let root=document.querySelector(opts.root) 
          assert(root,`找不到：${opts.root}`)
          return root
        }else if(opts.root instanceof HTMLElement){
		  return opts.root
        }else{
          assert(false,'root不合法')
        }
      }
      render(){
        let div=document.createElement('div');
        div.className='v-hd';
        div.innerHTML=this._data.title;
        let ul=document.createElement('ul');
        ul.className='user-list';
        let arr=[];
        this.data.forEach(data=>{
          arr.push(`
            <li class="row">
              <a href="${data.href}" class="cver">
                <img src="${data.avatar}" alt="">
              </a>
              <div class="info">
                <p class="row aic">
                  <a href="${data.href}" class="nm-icn">${data.name}</a>
                  ${data.vip?'<img src="./img/vip.png" alt="">':''}
                </p>
                <p class="label">${data.title}</p>
              </div>
            </li>
          `);
        });
        ul.innerHTML=arr.join('');
        this._root.innerHTML='';
        this._root.appendChild(div);
        this._root.appendChild(ul);
      }
    }, {
      construct(cls, args){
        let obj=new cls(...args);

        assert(args[0].data,'data不能为空') 
        assert(typeof args[0].data=='function','data必须为函数')
        let data=args[0].data()
        assert(data,'data必须有返回值') 
        assert(typeof data=='object','data必须为object')
          
        for(let name in data){
          obj[name]=data[name]
        }
 
        obj.render();
        // 拦截set操作
        return new Proxy(obj, {
          set(obj, name, val){
            obj[name]=val;
            obj.render(); 
          }
        })
      }
	});
      
    let list=new HotList({
		root:'.hot-host',
        data(){
            return {
                title:'热门主播',
                data:[{
                    name: 'blue',
                    href: 'http://www.zhinengshe.com/',
                    avatar: 'img/1407374893913311.jpg',
                    vip: false,
                    title: '打杂的'
                },{
                	name: 'blue',
                    href: 'http://www.zhinengshe.com/',
                	avatar: 'img/1407374893913311.jpg',
                	vip: false,
                	title: '打杂的'
            	}]
            }
        }
    })
  </script>
</body>
</html>
```

> 进一步封装

```js
# common.js
function _getRoot(options){
    assert(options.root, 'root不能为空');
    if(typeof options.root=='string'){
        let root=document.querySelector(options.root);
        assert(root, `找不到: ${options.root}`);
        return root;
    }else if(options.root instanceof HTMLElement){
        return options.root;
    }else{
        assert(false, 'root不合法');
    }
}

function _getData(options){
    assert(options.data, `data不能没有`);
    assert(typeof options.data=='function', `data必须是函数`);
    let data=options.data();
    assert(data, 'data必须有返回值');
    assert(typeof data=='object', 'data必须是object');
    return data;
}

function extendAndListenClassInstance(cls){
    return new Proxy(cls, {
        construct(cls, args){
            let obj=new cls(...args);
            obj._root=_getRoot(args[0]);
            let data=_getData(args[0]);
            for(let name in data){
                obj[name]=data[name];
            }
            obj.render();
            return new Proxy(obj, {
                set(obj, name, val){
                    obj[name]=val;
                    obj.render();
                }
            });
        }
    });
}
```

```js
# index.html
const HotList=extendAndListenClassInstance(class {
    render(){
        let div=document.createElement('div');
        div.className='v-hd';
        div.innerHTML=this.title;

        let ul=document.createElement('ul');
        ul.className='user-list';

        let arr=[];
        this.data.forEach(data=>{
            arr.push(`
            <li class="row">
            <a href="${data.href}" class="cver">
            <img src="${data.avatar}" alt="">
            </a>
            <div class="info">
            <p class="row aic">
            <a href="${data.href}" class="nm-icn">${data.name}</a>
            ${data.vip?'<img src="./img/vip.png" alt="">':''}
            </p>
            <p class="label">${data.title}</p>
            </div>
            </li>
            `);
        });
        ul.innerHTML=arr.join('');
        this._root.innerHTML='';
        this._root.appendChild(div);
        this._root.appendChild(ul);
    }
});

let list=new HotList({
    root: '.hot-host',
    data(){
        return {
            title: '热门主播',
            data: [
                {
                    name: 'blue',
                    href: 'http://www.zhinengshe.com/',
                    avatar: 'img/1407374893913311.jpg',
                    vip: false,
                    title: '打杂的'
                },
                {
                    name: 'blue',
                    href: 'http://www.zhinengshe.com/',
                    avatar: 'img/1407374893913311.jpg',
                    vip: false,
                    title: '打杂的'
                }
            ]
        }
    }
});
```

> 上例中的缺点是：对数据变化的监听仍然只是第一层，对象或数组内的数据发生变化，检测不到

## 第二部分 DOM和虚拟DOM

### 1、DOM操作

#### 1）DOM节点查找

##### 父节点

- parentNode

##### 子节点

- children--只有元素节点

- childNodes--所有节点=元素+文本+注释

  ```js
  // <div id="div1">
  //     <span></span>
  //     <span></span>
  //     <span></span>
  //     <!---->
  // </div>
  let div=document.getElementById('div1')
  console.log(div.childodes) // [text,span,text,span,text,span,text,comment,text]
  
  console.log(div.childodes[0].nodeType) // 3
  console.log(div.childodes[0].nodeType==document.TEXT_NODE) // true
  
  console.log(div.childodes[1].nodeType) // 1
  console.log(div.childodes[1].nodeType==document.ELEMENT_NODE) // true
  
  console.log(div.childodes[7].nodeType) // 8
  console.log(div.childodes[7].nodeType==document.COMMENT_NODE) // true
  ```

  ```js
  document.documentElement // HTML
  document.documentElement.parentNode // DOCUMENT，是一个特殊的节点，里面保存了操作dom的方法
  document.nodeType // 9
  document.nodeType == DOCUMENT_NODE // true
  ```

  > document有父级吗？document.parentNode ==> null，但是从对象的所属关系上讲属于window
  >
  > 其他还有，2--ATTRIBUTE_NODE，4--CDATA

##### 兄弟节点

- previousSibling

- nextSibling

  ```js
  // <div id="div1">
  //     <span></span>
  //     <span id="s1"></span>
  //     <span></span>
  //     <!---->
  // </div>
  let s1=document.getElementById('s1')
  console.log(s1.previousSibling) // #text，IE低版本获取的是#span
  console.log(s1.previousElementSibling) // #span，但是高版本浏览器才支持
  // 兼容写法
  let prev = s1.previousElementSibling || s1.previousSibling
  ```

#### 2）DOM节点操作

##### 创建节点

- 创建元素节点

  ```js
  let div=document.getElementById('div1');
  let span=document.createElement('span');
  span.innerHTML='dfasdsgdf';
  div.appendChild(span);
  ```

- 创建文本节点

  ```js
  let div=document.getElementById('div1');
  let txt=document.createTextNode('dfsdfghfggdghfhgh');
  div.appendChild(txt);
  ```

- 创建注释节点

  ```js
  let div=document.getElementById('div1');
  let cmt=document.createComment('');
  div.appendChild(cmt);
  ```

- 创建其他标准下的节点

  ```js
  document.createElementNS
  ```

  > SVG中会讲

##### 添加节点

- appendChild:`parentNode.appendChild(childNode)`

- insertBefore:`parentNode.insertBefore(newNode,targetNode)`

  ```js
  let div=document.getElementById('div1');
  let span=document.createElement('span');
  span.innerHTML='555555';
  div.insertBefore(span, document.getElementById('s1'));
  ```

- 获取一个元素直接插入到另一个元素里面，相当于从原来的元素中移动或剪切到新的元素里面(包括文档碎片)

  ```html
  <div id="div1">
    	<span>asdfasdf</span>
  </div>
  <div id="div2"></div>
  <script>
      let span=document.querySelector('#div1 span');
      let div2=document.getElementById('div2');
      // 移动span到div2
      //div2.appendChild(span);
      // 复制span到div2
      //let sp=span.cloneNode(true);
      //div2.appendChild(sp);
  </script>
  ```

  > 如果需要保留原来的，则需要cloneNode()

##### 删除/替换节点

- removeChild：`parentNode.removeChild(childNode)`

- replaceChild：`parentNode.replaceChild(newNode,targetNode)`

  ```js
  let div=document.getElementById('div1');
  let span=document.createElement('span');
  span.innerHTML='555555';
  div.replaceChild(span, document.getElementById('s1'));
  ```

#### 3）文档碎片

##### 基本使用

```js
    let root=document.getElementById('div1');

    let frag=document.createDocumentFragment();

    let h2=document.createElement('h2');
    h2.innerHTML='asdfasdewrefhcfghjg';
    let ul=document.createElement('ul');
    ul.innerHTML='<li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li>';

	frag.appendChild(h2);
    frag.appendChild(ul);

	root.appendChild(frag)
```

##### 优点总结

- DOM为什么慢？
  - 第一，臃肿
  - 第二，DOM插入一个元素DOM树更新（层级关系），还要进行重排（元素的插入导致其他受影响）

- 文档碎片为什么好？
  - 第一，不会多出一层
  - 第二，所有的更新、重排一次搞定，不用多次进行

```js
let root=document.getElementById('div1');
let frag=document.createDocumentFragment();

let h2=document.createElement('h2');
h2.innerHTML='asdfasdewrefhcfghjg';
let ul=document.createElement('ul');
ul.innerHTML='<li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li>';

frag.appendChild(h2);
frag.appendChild(ul);

let start=Date.now();
for(let i=0;i<50000;i++){
    let ele=frag.cloneNode(true);
    root.appendChild(ele);
}
alert(Date.now()-start);
```

```js
let root=document.getElementById('div1');

let start=Date.now();
for(let i=0;i<50000;i++){
    let h2=document.createElement('h2');
    h2.innerHTML='asdfasdewrefhcfghjg';
    let ul=document.createElement('ul');
    ul.innerHTML='<li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li><li>stesdgfgsfdsgfdsg</li>';
    root.appendChild(h2);
    root.appendChild(ul);
}
alert(Date.now()-start);
```

> 性能提升了3倍

##### 案例：动态渲染

```html
<div id="root">
    <!-- 模板元素 -->
    <div class="box">
        <h2>sssss</h2>
        <ul>
            <li>asdfasdf</li>
            <li>rwere</li>
        </ul>
    </div>
</div>
<script>
    let arr=new Proxy([12,5,8], {
        set(arr, name, val){
            arr[name]=val;
            render();
            return true;
        }
    });
    let root=document.querySelector('#root');
    let box=document.querySelector('.box');
    let frag=document.createDocumentFragment();
    # 把box移动到frag中
    frag.appendChild(box);

    let timer=null;
    function render(){
        clearTimeout(timer);
        timer=setTimeout(function (){
            root.innerHTML='';
            arr.forEach(item=>{
                let el=frag.cloneNode(true);
                el.children[0].getElementsByTagName('h2')[0].innerHTML=item;
                root.appendChild(el);
            });
        }, 0);
    }
    render();
</script>
```

#### 4）DOM属性操作

##### 获取属性

```html
<div id="div1" title="aaa" userid="1"></div>
<script>
	let div1=document.getElementById('div1');
    # 内置属性
    console.log(div1.title);//aaa
	console.log(div1.getAttribute('title')); //aaa
    # 自定义属性
    console.log(div1.userid);//undefined
    console.log(div1.getAttribute('userid'));//1
</script>
```

##### 设置属性

```html
<div id="div1" title="aaa" userid="1"></div>
<script>
	let div1=document.getElementById('div1');
    # 内置属性
    console.log(div1.title="aaa")
	console.log(div1.setAttribute('title',"aaa"));
    # 自定义属性
    console.log(div1.userid="1");
    let div2=div1.cloneNode(true);
    alert(div2.getAttribute('userid'));//没有userid
    
    console.log(div1.setAttribute('userid',1));
    let div3=div1.cloneNode(true);
    alert(div3.getAttribute('userid'));//有userid
</script>
```

> getAttribute和setAttribute可以获取和设置自定义属性

##### 所有属性

```html
<div id="div1" title="aa" onclick="fn()" :value="aaa"></div>
<script>
    let div1=document.getElementById('div1');
    Array.from(div1.attributes).forEach(attr=>{
        console.log(attr.name, attr.value);
    });
</script>
```

##### 自定义属性

```html
<div id="div1" title="dsfas" data-aaa="123" data-user-id="4578"></div>
<script>
    let div1=document.getElementById('div1');
    console.log(div1.dataset);
</script>
```

> dataset受官方保护，在未来的HTML版本中不会有冲突
>
> 可以直接遍历

#### 5）编译DOM初级

##### 案例：HTML

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title></title>
    </head>
    <body>
        <div id="root">
            姓名：{{name}}
            <button type="button" @click="add">a+=6</button>
            <input type="text" :value="a">
            <span :title="name"></span>
            <div class="">-----------------</div>
            {{a+b+json.n}}
        </div>
        <script src="blue.js" charset="utf-8"></script>
    </body>
</html>
```

##### 案例：JS

```JS
function assert(exp, msg){
    if(!exp){
        throw new Error(msg);
    }
}
function _getElement(obj){
    assert(obj, 'root is required');
    if(typeof obj=='string'){
        let el=document.querySelector(obj);
        assert(el, `${obj} not found`);
        return el;
    }else if(obj instanceof HTMLElement){
        return obj;
    }else{
        assert(false, 'root is invaild');
    }
}
class Blue{
    constructor(options={}){
        this._root=_getElement(options.root);
        this.timer=0;
        //options.data() assert从简
        const _this=this;
        let proxy=new Proxy(options.data(), {
            get(data, name){
                assert(name in data, `data '${name}' is not found`);
                return data[name];
            },
            set(data, name, val){
                data[name]=val;
                _this.update();
                return true;
            }
        });
        this._parent=this._root.parentNode;
        // this._template=document.createDocumentFragment();
        // this._template.appendChild(this._root);
        this._template=this._root.cloneNode(true);
        //保存所有methods
        this._methods=options.methods||{};
        this.update();
        this._data=proxy;
        return proxy;
    }
    update(){
        clearTimeout(this.timer);
        this.timer=setTimeout(()=>{
            this.render();
        }, 0);
    }
    render(){
        console.log('render');
        let root=this._template.cloneNode(true);
        //1.找到所有的模板({{}})
        Array.from(root.childNodes).forEach(child=>{
            if(child.nodeType==document.TEXT_NODE){
                child.data=child.data.replace(/\{\{[^\}]+\}\}/g, (str)=>{
                    str=str.substring(2, str.length-2).trim();
                    //解析表达式字符串，例如：a+b:报错找不到a和b
                    //return eval(str)
                    //解决方案1：缺点es5严格模式下，with不能用
                    //with(this._data){
                    //    return eval(str)
                    //}
                    let arr=[];
                    for(let key in this._data){
                        # eval会把第一层引号去掉，那么原本字符串字面量就会变成不存在的变量
                        # 所以需要JSON.stringify再额外加上一层引号
                        arr.push(`let ${key}=${JSON.stringify(this._data[key])};`);
                    }
                    arr.push(str);
                    return eval(arr.join(''));
                });
            }
        });
        //2.找到所有的事件
        Array.from(root.children).forEach(child=>{
            Array.from(child.attributes).forEach(attr=>{
                if(attr.name.startsWith('@')){
                    let evname=attr.name.substring(1);
                    child.addEventListener(evname, ()=>{
                        let arr=[];
                        for(let key in this._methods){
                         arr.push(`let ${key}=this._methods[${JSON.stringify(key)}];`);
                        }
                        arr.push(attr.value+'.call(this._data)');
                        eval(arr.join(''));
                    }, false);
                }
            });
        });
        //新的元素换进去
        this._parent.replaceChild(root, this._root);
        this._root=root;
    }
}
let blue=new Blue({
    root: '#root',
    data(){
        return {
            name: 'blue',
            a: 12,
            b: 5,
            c: 99,
            json: {
                n: 99
            }
        }
    },
    methods: {
        add(){
            this.a+=6;
        }
    }
})
```

> 在js中构造函数，默认返回的是this，但是却可以返回复杂类型的数据来覆盖返回的this

### 2、虚拟DOM

#### 1）模拟promise

```js
class Promise2{
    constructor(cb){
        this.end=false;
        this.err=false;
        this.result=null;

        cb((...args)=>{
            this.end=true;
            this.err=false;
            this.result=args;

            if(this.succ){
                this.succ(...args);
            }
        }), (...args)=>{
            this.end=true;
            this.err=true;
            this.result=args;

            if(this.faild){
                this.faild(...args);
            }
        });
    }

    then(succ, faild){
        this.succ=succ;
        this.faild=faild;

        if(this.end){
            if(this.err){
                faild(...this.result);
            }else{
                succ(...this.result);
            }
        }
    }
}
```

#### 2）虚拟DOM简介

- 什么是虚拟DOM
  - 没有标准
  - 用一个对象表述所有的节点

- 为什么要有虚拟DOM
  - 真实DOM慢，比其他操作慢个千儿八百倍不是事
- 如何创建虚拟DOM
  - 精确复制DOM
  - 虚拟DOM产生的变化——同步回真实DOM

#### 3）抽象虚拟DOM--框架

##### common.js

```js
function assert(exp, msg){
  if(!exp){
    throw new Error(msg||'ASSERT ERROR');
  }
}
```

##### vNode.js

```js
class VNode{
  constructor(dom){
    assert(dom,'DOM不能为空');
    assert(dom instanceof Node,'错误的节点类型');
    this._dom=dom;
  }
}
```

##### vElement.js

```js
class VElement extends VNode{
  constructor(dom){
    super(dom)
    this._type=dom.tagName.toLowerCase()
    // 获取属性节点列表
    this._attrs={}
    Array.from(dom.attributes).forEach(attr=>{
      this._attrs[attr.name]=attr.value
    })
    // 获取子元素虚拟节点
    this._children=[]
    Array.from(dom.childNodes).forEach(child=>{
      switch(child.nodeType){
        case document.ELEMENT_NODE:
          this._children.push( new VElement(child) )
        break;
        case document.TEXT_NODE:
          let textNode=new VText(child)
          if(textNode._text) this._children.push( textNode );
        break;
        default:
          console.log('不要了')
      }
    })
  }
}
```

##### vText.js

```js
class VText extends VNode{
  constructor(dom){
    super(dom)
    this._text=dom.data.trim()
  }
}
```

#### 4）抽象虚拟DOM--指令

##### vElement.js

```js
(function(window,undefined){
  function createAttrs(dom){
    let attrs={}
    Array.from(dom.attributes).forEach(attr=>{
      attrs[attr.name]=attr.value
    })
    return attrs
  }
  function createDirectives(attrs){
    let directives=[]
    // 指令类型：v-bind              :
    // 指令参数: v-bind:title        :title
    // 指令的值: v-bind:title="aaa"  :title="aaa"
    // 注意需要处理：区分v-show=""和v-show(不写默认为 true) 
    for(let name in attrs){
      if(name.startsWith(':')){
        directives.push({
          name:'bind',
          arg:name.substring(1),
          value:attrs[name]
        })
      }else if(name.startsWith('@')){
        directives.push({
          name:'on',
          arg:name.substring(1),
          value:attrs[name]
        })
      }else if(name.startsWith('v-')){
        let [tmp_name,arg]=name.split(':')
        tmp_name=tmp_name.substring(2)
        directives.push({
          name:tmp_name,
          arg:arg,
          value:attrs[name]
        })
      }
    }
    return directives
  }
  function createListeners(directives){
    assert(directives)
    let listeners=[]
    directives.filter(directive=>directive.name=='on').forEach(({arg, value})=>{
      listeners.push({
        evt: arg,
        handler:value
      })
    })
    return listeners
  }
  function createChildren(dom){
    let children=[]
    Array.from(dom.childNodes).forEach(child=>{
      switch(child.nodeType){
        case document.ELEMENT_NODE:
          children.push( new VElement(child) )
        break;
        case document.TEXT_NODE:
          let textNode=new VText(child)
          if(textNode._text) children.push( textNode );
        break;
        default:
          console.log('不要了')
      }
    })
    return children
  }
  window.VElement=class VElement extends VNode{
    constructor(dom){
      super(dom)
      this._type=dom.tagName.toLowerCase()
      // 获取属性节点列表
      this._attrs=createAttrs(dom)
      this._directives=createDirectives(this._attrs)
      this._listeners=createListeners(this._directives)
      // 获取子元素虚拟节点
      this._children=createChildren(dom)
    }
  }
})(window)
```

#### 5）虚拟DOM编译--插值

##### 框架搭建

###### vNode.js

```JS
class VNode{
  constructor(dom){
    assert(dom,'DOM不能为空');
    assert(dom instanceof Node,'错误的节点类型');
    this._dom=dom;
  }
  render() {
    assert(false,'请重写子类的render方法')
  }
}
```

> 提供顶层render方法，如果子类没有重写该方法，则执行此render

###### vElement.js

```js
(function(window,undefined){
  function createAttrs(dom){
    let attrs={}
    Array.from(dom.attributes).forEach(attr=>{
      attrs[attr.name]=attr.value
    })
    return attrs
  }
  function createDirectives(attrs){
    let directives=[]
    // 指令类型：v-bind              :
    // 指令参数: v-bind:title        :title
    // 指令的值: v-bind:title="aaa"  :title="aaa"
    // 注意需要处理：区分v-show=""和v-show(不写默认为 true) 
    for(let name in attrs){
      if(name.startsWith(':')){
        directives.push({
          name:'bind',
          arg:name.substring(1),
          value:attrs[name]
        })
      }else if(name.startsWith('@')){
        directives.push({
          name:'on',
          arg:name.substring(1),
          value:attrs[name]
        })
      }else if(name.startsWith('v-')){
        let [tmp_name,arg]=name.split(':')
        tmp_name=tmp_name.substring(2)
        directives.push({
          name:tmp_name,
          arg:arg,
          value:attrs[name]
        })
      }
    }
    return directives
  }
  function createListeners(directives){
    assert(directives)
    let listeners=[]
    directives.filter(directive=>directive.name=='on').forEach(({arg, value})=>{
      listeners.push({
        evt: arg,
        handler:value
      })
    })
    return listeners
  }
  function createChildren(dom){
    let children=[]
    Array.from(dom.childNodes).forEach(child=>{
      switch(child.nodeType){
        case document.ELEMENT_NODE:
          children.push( new VElement(child) )
        break;
        case document.TEXT_NODE:
          let textNode=new VText(child)
          if(textNode._text) children.push( textNode );
        break;
        default:
          console.log('不要了')
      }
    })
    return children
  }
  window.VElement=class VElement extends VNode{
    constructor(dom){
      super(dom)
      this._type=dom.tagName.toLowerCase()
      // 获取属性节点列表
      this._attrs=createAttrs(dom)
      this._directives=createDirectives(this._attrs)
      this._listeners=createListeners(this._directives)
      // 获取子元素虚拟节点
      this._children=createChildren(dom)
    }
    render(){

    }
  }
})(window)
```

> 重写父类render方法

###### vText.js

```js
class VText extends VNode{
  constructor(dom){
    super(dom)
    this._text=dom.data.trim()
  }
  render() {
    
  }
}
```

> 重写父类render方法

###### vComponent.js

```js
class VComponent extends VElement{
  constructor(opts){
    assert(opts,`请传递component参数`)
    assert(opts.el,`请传递根元素`)
    let el=null
    if(typeof opts.el=='string'){
      el=document.querySelector(opts.el);
      assert(el, `element "${opts.el}" is not found`)
    }else if(opts.el instanceof HTMLElement){
      el=opts.el
    }
    super(el)
    this._el=el
    const _this=this
    this._data=new Proxy(opts.data||{}, {
      get(data, name){
        assert(name in data, `data "${name}" is not defined`)
        return data[name]
      },
      set(data, name, value){
        data[name]=value;
        _this.render();
        return true;
      }
    })
    this._methods=opts.methods||{}
  }
  render(){
    // 渲染自己

    // 渲染子级
    this._children.forEach(child=>child.render())
  }
}
```

> 获取元素+获取数据+监听数据+渲染数据

###### index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="common.js"></script>
  <script src="vNode.js"></script>
  <script src="vElement.js"></script>
  <script src="vText.js"></script>
  <script src="vComponent.js"></script>
</head>
<body>
  <div id="root" title="aaa" onclick="fn()" v-show :value="a" v-if="true" v-on:click="fn()" @mouseover="fn2()"> 
    <h2>标题</h2>
    asdasdadad
    <ul>
      <li>1</li>
      <li>2</li>
      <li>3</li>
    </ul>
  </div>
  <script>
    let cmp=new VComponent({
      el:'#root',
      data:{
        a:12,b:5
      },
      methods: {
        fn(){
          alert('a')
        },
        fn2(){
          this.a+=5
        }
      }
    })
    cmp.render()
  </script>
</body>
</html>
```

##### 解析模板

###### vText.js

```js
class VText extends VNode{
  constructor(dom){
    super(dom)
    this._text=dom.data.trim()
  }
  render(){
    let start=0
    let end=0
    while((start=this._text.indexOf('[[', start))!=-1){
      let block_num=0    //方括号的数量
      let quote_num=0    //单引号的数量
      for(let i=start;i<this._text.length;i++){
        if(this._text[i]==']'){
          if(quote_num==0) block_num--
        }else if(this._text[i]=='['){
          if(quote_num==0) block_num++
        }else if(this._text[i]=="'" && this._text[i-1]!="\\"){
          if(quote_num==0){
            quote_num=1
          }else{
            quote_num=0
          }
        }
        if(block_num==0){
          end=i
          break
        }
      }
      assert(block_num==0, `"${this._text} is invaild"`)
      let exp=this._text.substring(start, end+1)
      exp=exp.substring(2, exp.length-2).trim()
      start=end+1;
      //TODO
      let str_exp=[]
      for(let key in this._component._data){     
        str_exp.push(`let ${key}=${JSON.stringify(this._component._data[key])};`)
      }
      eval(str_exp.join('')+'console.log('+exp+')')
    }
  }
}
```

> 假如不加引号的判断：`[[a+']]'+b]]` ==> `a+'` ,加上才会得到正确的表达式`a+']]'+b`

##### 传递数据

###### vElement.js

```js
(function(window,undefined){
  function createAttrs(dom){
    let attrs={}
    Array.from(dom.attributes).forEach(attr=>{
      attrs[attr.name]=attr.value
    })
    return attrs
  }
  function createDirectives(attrs){
    let directives=[]
    // 指令类型：v-bind              :
    // 指令参数: v-bind:title        :title
    // 指令的值: v-bind:title="aaa"  :title="aaa"
    // 注意需要处理：区分v-show=""和v-show(不写默认为 true) 
    for(let name in attrs){
      if(name.startsWith(':')){
        directives.push({
          name:'bind',
          arg:name.substring(1),
          value:attrs[name]
        })
      }else if(name.startsWith('@')){
        directives.push({
          name:'on',
          arg:name.substring(1),
          value:attrs[name]
        })
      }else if(name.startsWith('v-')){
        let [tmp_name,arg]=name.split(':')
        tmp_name=tmp_name.substring(2)
        directives.push({
          name:tmp_name,
          arg:arg,
          value:attrs[name]
        })
      }
    }
    return directives
  }
  function createListeners(directives){
    assert(directives)
    let listeners=[]
    directives.filter(directive=>directive.name=='on').forEach(({arg, value})=>{
      listeners.push({
        evt: arg,
        handler:value
      })
    })
    return listeners
  }
  function createChildren(dom,component){
    let children=[]
    Array.from(dom.childNodes).forEach(child=>{
      switch(child.nodeType){
        case document.ELEMENT_NODE:
          # 传递根组件
          children.push( new VElement(child,component) )
        break;
        case document.TEXT_NODE:
          # 传递根组件
          let textNode=new VText(child,component)
          if(textNode._text) children.push( textNode );
        break;
        default:
          console.log('不要了')
      }
    })
    return children
  }
  window.VElement=class VElement extends VNode{
    constructor(dom,component){
      super(dom)
      # 获取根组件
      this._component=component||this
      this._type=dom.tagName.toLowerCase()
      // 获取属性节点列表
      this._attrs=createAttrs(dom)
      this._directives=createDirectives(this._attrs)
      this._listeners=createListeners(this._directives)
      // 获取子元素虚拟节点
      # 传递根组件
      this._children=createChildren(dom, this._component)
    }
    render(){

    }
  }
})(window)
```

> VElement的子类VComponent调用了super实际上相当于调用了VElement的constructor，但是VElement的constructor中的this会指向VComponent。所以子类VComponent就拥有了父类VElement构造中的属性。
>
> 相当于ES5中的借用构造函数继承。
>
> ```js
> function A(name,age){
>     this.name=name
>     this.age=age
>     console.log(this)//{name: "SSL", age: 18}
> }
> function B(name,age){
>     A.call(this,name,age)
> }
> new B('SSL',18)
> ```

> 问题：_component循环引用问题

###### vText.js

```js
class VText extends VNode{
  constructor(dom,component){
    super(dom)
    this._component=component
    this._text=dom.data.trim()
  }
  render(){
    let start=0
    let end=0
    while((start=this._text.indexOf('[[', start))!=-1){
      let block_num=0    //方括号的数量
      let quote_num=0    //单引号的数量
      for(let i=start;i<this._text.length;i++){
        if(this._text[i]==']'){
          block_num--
        }else if(this._text[i]=='['){
          block_num++
        }else if(this._text[i]=="'" && this._text[i-1]!="\\"){
          if(quote_num==0){
            quote_num=1
          }else{
            quote_num=0
          }
        }
        if(block_num==0){
          end=i
          break
        }
      }
      assert(block_num==0, `"${this._text} is invaild"`)
      let exp=this._text.substring(start, end+1)
      exp=exp.substring(2, exp.length-2).trim()
      console.log(exp)
      start=end+1;
      //TODO
    }
  }
}
```

### 3、第一部分作业

#### 1）polifill

###### reduce

```js
// [1,2,3].reduce((tmp, item, index)=>{
//   return tmp+item;
// }, initial)
Array.prototype.reduce=Array.prototype.reduce||function(cb,defaultValue){
    var start=0
    if(typeof defaultValue =='undefined'){
        defaultValue=this[0]
        start=1
    }
    for(start;start<this.length;start++){
        defaultValue=cb(defaultValue,this[start],start)
    }
    return defaultValue
}

let arr=[12,5,7,9]
let sum=arr.reduce((tmp,item,index)=>{
    return tmp+item
})
```

###### map

```js
// let arr2=[1,2,3].map((item, index)=>{return item+5});
// arr2=>[6,7,8]
Array.prototype.map=Array.prototype.map||function (cb){
  let result=[];
  for(var i=0;i<this.length;i++){
    result.push(cb(this[i], i));
  }
  return result;
};
```

###### filter

```js
// [1,2,3,4,5,6].filter((item, index)=>item%2);
// [1,3,5]
Array.prototype.filter=Array.prototype.filter||function (cb){
  var result=[];
  for(let i=0;i<this.length;i++){
    if(cb(this[i], i)){
      result.push(this[i]);
    }
  }
  return result;
};
```

###### Array.from

```JS
// Array.from({0:13,1:22,length:2}) ==> [13,22]
// Array.from('abc') ==> ['a','b','c']
Array.from=Array.from||function (obj){
  if(typeof obj.length=='number'){
    var result=[];
    for(var i=0;i<obj.length;i++){
      result.push(obj[i]);
    }
    return result;
  }else{
    return [];
  }
}
```

#### 2）豆瓣

##### 面向对象

###### 抽象弹窗对象

```js
// display: true/false
// tabs: [{ico, text}, ...]
// cur: 0
function assert(exp, msg){
  if(!exp){
    throw new Error(msg||'ASSERT ERROR');
  }
}
class LiveTab{
  constructor(el, tabs){
    assert(el);
    assert(el instanceof HTMLElement);
    assert(tabs);
    assert(tabs instanceof Array);
    tabs.forEach(tab=>assert(tab.ico && tab.text));

    this._display=false;
    this._cur=0;
    this._tabs=tabs;
    this._el=el;
 
    this.render();
  }
  setCur(n){
    assert(typeof n=='number');
    assert(n>=0 && n<this._tabs.length);
    if(n==this._cur) return;
    this._cur=n;
    this.render();
    # 执行onchange对应的函数
    this.onchange && this.onchange(this._tabs[n]);
  }
  show(){
    this._display=true;
    this.render();
  }
  hide(){
    this._display=false;
    this.render();
  }
  render(){
    if(this._display){
      let pop=document.createElement('div');
      pop.className='live-tab';
      pop.innerHTML=`
          <div>
            <div class="wave s">
              <div class="_2MUigC9rTs5TkYEURNVt2q"></div>
              <div class="JvceXUqvhLlL6h0qs-nzk"></div>
              <div class="_3DmB-mG2d4JJdAo4ugPaTU"></div>
              <div class="_3GgHqQVPiHBR5MylzyjNls"></div>
            </div>
            <div class="container">
              <ul class="column">
                ${
                  this._tabs.map((tab,index)=>(`
                    <li class="select-item row aic ${index==this._cur?'active':''}">
                      <img class="img" src="${tab.ico}" alt="">
                      ${tab.text}
                    </li>
                  `)).join('')
                }
              </ul>
              <hr class="_24GcLdJnvrJ23aKnPCasbJ">
              其他静态html代码省略.........
            </div>
          </div>
      `;
      this._el.parentNode.replaceChild(pop, this._el);
      this._el=pop;
      Array.from(this._el.querySelectorAll('.select-item')).forEach((item, index)=>{
        item.onclick=()=>this.setCur(index);
      });
    }else{
      let comment=document.createComment('');
      this._el.parentNode.replaceChild(comment, this._el);
      this._el=comment;
    }
  }
}
```

###### 使用弹窗对象

```html
<div class="b-tab-title" id="btn1">
    <span>豆瓣精选 MHz</span>
    <svg title="Title" viewBox="134 78 9 16" height="16" width="16" class="icon"
         style="vertical-align: middle; top: -2px; margin-left: 14px;">
        <desc>Icon</desc>
        <path d="M140.895865,89.8459828 C140.690998,90.0513391 140.358992,90.0513391 140.15362,89.8459828 C139.948793,89.640129 139.948793,89.3071763 140.15362,89.1013146 L143.246666,86.000004 L140.15362,82.8981639 C139.948793,82.6927996 139.948793,82.3593654 140.15362,82.1539931 C140.358992,81.948669 140.690998,81.948669 140.895865,82.1539931 L144.360483,85.6274131 C144.56535,85.8332669 144.56535,86.1662116 144.360483,86.3720814 L140.895865,89.8459828 Z M136.618268,89.8459828 C136.823135,90.0513391 137.155141,90.0513391 137.360513,89.8459828 C137.56534,89.640129 137.56534,89.3071763 137.360513,89.1013146 L134.267467,86.000004 L137.360513,82.8981639 C137.56534,82.6927996 137.56534,82.3593654 137.360513,82.1539931 C137.155141,81.948669 136.823135,81.948669 136.618268,82.1539931 L133.15365,85.6274131 C132.948783,85.8332669 132.948783,86.1662116 133.15365,86.3720814 L136.618268,89.8459828 Z" stroke="none" fill="#6BBD7A" fill-rule="evenodd" transform="translate(138.757066, 86.000000) rotate(90.000000) translate(-138.757066, -86.000000) ">
        </path>
    </svg>
</div>
<!-- 弹出框 -->
<div id="live"></div>

<script>
	let cmp=new LiveTab(document.getElementById('live'), [
      {ico: 'https://img3.doubanio.com/icon/ul188738892-1.jpg', text: '豆瓣精选 MHz'},
      {ico: 'https://img3.doubanio.com/icon/ul188738892-1.jpg', text: '我的红心歌曲'},
      {ico: 'https://img3.doubanio.com/icon/ul188738892-1.jpg', text: '豆瓣精选 MHz'},
      {ico: 'https://img3.doubanio.com/icon/ul188738892-1.jpg', text: 'Blue'}
    ]);
    let oBtn=document.getElementById('btn1');
    oBtn.onclick=function (ev){
      ev.cancelBubble=true;
      cmp.show();
    };
    document.onclick= ()=>cmp.hide();
    cmp.onchange=function (tab){
      oBtn.children[0].innerHTML=tab.text;
    }
</script>
```

##### 可响应

###### 修改弹窗对象

```js
// display: true/false
// tabs: [{ico, text}, ...]
// cur: 0
function assert(exp, msg){
  if(!exp){
    throw new Error(msg||'ASSERT ERROR');
  }
}
class LiveTab{
  constructor(el, tabs){
    assert(el);
    assert(el instanceof HTMLElement);
    assert(tabs);
    assert(tabs instanceof Array);
    tabs.forEach(tab=>assert(tab.ico && tab.text));

    this._tabs=tabs;
    this._el=el;
    # 构建可响应数据对象
 	let _this=this;
    this._data=new Proxy({
      display: false,
      cur: 0
    }, {
      get(data, name){
        return data[name];
      },
      set(data, name, val){
        switch(name){
          case 'cur':
            assert(typeof val=='number');
            assert(val>=0 && val<tabs.length);
            _this._data.onchange &&  _this._data.onchange(_this._tabs[val]);
            break;
          case 'display':
            assert(typeof val=='boolean');
            break;
        }
        data[name]=val;
        _this.render();
        return true;
      }
    });
    this.render();
    # 返回可响应对象
    return this._data
  }
  
  render(){
    if(this._data.display){
      let pop=document.createElement('div');
      pop.className='live-tab';
      pop.innerHTML=`
          <div>
            <div class="wave s">
              <div class="_2MUigC9rTs5TkYEURNVt2q"></div>
              <div class="JvceXUqvhLlL6h0qs-nzk"></div>
              <div class="_3DmB-mG2d4JJdAo4ugPaTU"></div>
              <div class="_3GgHqQVPiHBR5MylzyjNls"></div>
            </div>
            <div class="container">
              <ul class="column">
                ${
                  this._tabs.map((tab,index)=>{
          			let current = this._data.cur;
          			return `
                      <li class="select-item row aic ${index==current?'active':''}">
                        <img class="img" src="${tab.ico}" alt="">
                        ${tab.text}
                      </li>
					`
      			  }).join('')
                }
              </ul>
              <hr class="_24GcLdJnvrJ23aKnPCasbJ">
              其他静态html代码省略.........
            </div>
          </div>
      `;
      this._el.parentNode.replaceChild(pop, this._el);
      this._el=pop;
      Array.from(this._el.querySelectorAll('.select-item')).forEach((item, index)=>{
        item.onclick=()=>this._data.cur=index;
      });
    }else{
      let comment=document.createComment('');
      this._el.parentNode.replaceChild(comment, this._el);
      this._el=comment;
    }
  }
}
```

###### 使用弹窗对象

```html
<div class="b-tab-title" id="btn1">
    <span>豆瓣精选 MHz</span>
    <svg title="Title" viewBox="134 78 9 16" height="16" width="16" class="icon"
         style="vertical-align: middle; top: -2px; margin-left: 14px;">
        <desc>Icon</desc>
        <path d="M140.895865,89.8459828 C140.690998,90.0513391 140.358992,90.0513391 140.15362,89.8459828 C139.948793,89.640129 139.948793,89.3071763 140.15362,89.1013146 L143.246666,86.000004 L140.15362,82.8981639 C139.948793,82.6927996 139.948793,82.3593654 140.15362,82.1539931 C140.358992,81.948669 140.690998,81.948669 140.895865,82.1539931 L144.360483,85.6274131 C144.56535,85.8332669 144.56535,86.1662116 144.360483,86.3720814 L140.895865,89.8459828 Z M136.618268,89.8459828 C136.823135,90.0513391 137.155141,90.0513391 137.360513,89.8459828 C137.56534,89.640129 137.56534,89.3071763 137.360513,89.1013146 L134.267467,86.000004 L137.360513,82.8981639 C137.56534,82.6927996 137.56534,82.3593654 137.360513,82.1539931 C137.155141,81.948669 136.823135,81.948669 136.618268,82.1539931 L133.15365,85.6274131 C132.948783,85.8332669 132.948783,86.1662116 133.15365,86.3720814 L136.618268,89.8459828 Z" stroke="none" fill="#6BBD7A" fill-rule="evenodd" transform="translate(138.757066, 86.000000) rotate(90.000000) translate(-138.757066, -86.000000) ">
        </path>
    </svg>
</div>
<!-- 弹出框 -->
<div id="live"></div>

<script>
	let cmp=new LiveTab(document.getElementById('live'), [
      {ico: 'https://img3.doubanio.com/icon/ul188738892-1.jpg', text: '豆瓣精选 MHz'},
      {ico: 'https://img3.doubanio.com/icon/ul188738892-1.jpg', text: '我的红心歌曲'},
      {ico: 'https://img3.doubanio.com/icon/ul188738892-1.jpg', text: '豆瓣精选 MHz'},
      {ico: 'https://img3.doubanio.com/icon/ul188738892-1.jpg', text: 'Blue'}
    ]);
    let oBtn=document.getElementById('btn1');
    oBtn.onclick=function (ev){
      ev.cancelBubble=true;
      cmp.display=true;
    };
    document.onclick= ()=>cmp.display=false;
    cmp.onchange=function (tab){
      oBtn.children[0].innerHTML=tab.text;
    }
</script>
```

#### 3）渲染组件

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="utf-8">
    <title></title>
    <style media="screen">
        .dialog {width:400px; height:300px; margin:10px auto; border:1px solid black;}
    </style>
</head>
<body>
    <div id="div1">
        <div class="">adfasdfsad</div>
        <Cmp1 click="fn"></Cmp1>
        <Cmp1></Cmp1>
        <UserLogin></UserLogin>
    </div>
    <script>
        //html元素->组件
        function Vue(options){
            //1.root搞定
            let root=null;
            if(typeof options.root=='string'){
                root=document.querySelector(options.root);
                if(!root){
                    throw new Error(`can't found ${options.root}`);
                }
            }else if(options.root instanceof HTMLElement){
                root=options.root;
            }else{
                throw new Error('root invaild');
            }
            //2.找出所有自定义元素
            let elements=root.getElementsByTagName('*');
            Array.from(elements).forEach(element=>{
                if(element.constructor==HTMLUnknownElement){
                    for(let cmpName in options.components){
                        if(cmpName.toLowerCase()==element.tagName.toLowerCase()){
                            let CmpCls=options.components[cmpName];
                            # ①传递需要添加事件的元素
                            let cmp=new CmpCls(element);
                            let res=cmp.render();
                            element.parentNode.replaceChild(res, element);
                        }
                    }
                }
            });
        }
        //抽象的
        class Component{
          # ②所有的组件都可以添加点击事件，所以在根组件接收元素
          constructor(el){
        	this._click=el.getAttribute('click');
          }
          render(){
            throw new Error(`render is required`);
          }
        }
        class Cmp1 extends Component{
            render(){
                let div=document.createElement('div');
                div.innerHTML='我是cmp1';
                # ③监听组建元素的点击事件，判断是否有继承而来的click函数，有则执行
                div.onclick=()=>{
                  if(this._click){
                    eval(this._click);
                  }
                };
                return div;
            }
        }
        class UserLogin extends Component{
            render(){
                let div=document.createElement('div');
                div.className="dialog";
                div.innerHTML='dsfasdfsd';
                return div;
            }
        }
        Vue({
            root: '#div1',
            components: {
                Cmp1, UserLogin
            },
            methods: {
                fn(){
                    alert('a');
                }
            }
        });
    </script>
</body>
</html>
```

## 第三部分 事件与队列

### 1、原生事件

#### 1）事件对象

##### 兼容性

##### 冒泡

##### 默认行为

##### 例子：阻止复制

```js
document.onkeydown=function (ev){
    # 阻止ctrl+c
    if(ev.ctrlKey && ev.keyCode==67){
        alert('本站文章需要加入VIP才能复制');
        ev.preventDefault();
    }
    # 阻止f12
    if(ev.keyCode==123){
        return false;
    }
};
document.oncontextmenu=function (ev){
    ev.preventDefault();
};
```

##### 例子：表达提交

```js
let form=document.querySelector('form');
form.onsubmit=function (ev){
    ev.preventDefault();
    alert('ajax');
};
```

##### target

##### 鼠标事件

###### 滚轮

```html
<div id="div1"></div>
<script>
    let div=document.getElementById('div1');
	# ie浏览器提供的事件兼容到IE6，但是chrome等也都支持
    div.onmousewheel=function (ev){
        # 获取滚动方向，正负代表方向，以120为基准越大滚动速度越快
        console.log(ev.wheelDelta);
    };
	# 如果要兼容更广的范围如火狐等，用下面的事件
    div.addEventListener('DOMMouseScroll', function (ev){
        # 获取滚动方向，正负代表方向，以3为基准越大滚动速度越快
        console.log(ev.defailt);
    }, false);
</script>
```

###### 位置

- clientX/clientY
- pageX/pageY
- offsetX/offsetY

###### 例子：拖拽

```html
<div id="div1"></div>
<script>
    let div=document.getElementById('div1');

    div.onmousedown=function (ev){
        let disX=ev.offsetX;
        let disY=ev.offsetY;
		//let disX=ev.pageX-div.offsetLeft
        //let disY=ev.pageY-div.offsetTop
        document.onmousemove=function (ev){
            div.style.left=ev.clientX-disX+'px';
            div.style.top=ev.clientY-disY+'px';
            //div.style.left=ev.pageX-disX+'px';
            //div.style.top=ev.pageY-disY+'px';
        };
        document.onmouseup=function (){
            document.onmousemove=null;
            document.onmouseup=null;
        };
    };
</script>
```

##### 键盘事件

#### 2）事件流

#### 3）事件绑定

#### 4）放大镜特效

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title></title>
        <style media="screen">
            .div1,.div2 {float:left; width:400px;height:400px;overflow:hidden;position:relative;}
            .div2 {margin-left:30px;display:none;}
            .mask {width:200px;height:200px;background:yellow;opacity:0.3;position:absolute;left:0; top:0;display:none;}
            .cover {position:absolute;left:0;top:0; z-index:9; width:100%;height:100%;}
            .div2 img {position:absolute;left:0;top:0;}
        </style>
    </head>
    <body>
        <div class="div1">
            <img src="img/small.jpg" alt="">
            <div class="mask"></div>
            <div class="cover"></div>
        </div>
        <div class="div2">
            <img src="img/big.jpg" alt="">
        </div>
        <script>
            let div1=document.querySelector('.div1');
            let mask=document.querySelector('.mask');
            let div2=document.querySelector('.div2');
            let img=document.querySelector('.div2 img');

            div1.onmouseover=function (){
                mask.style.display='block';
                div2.style.display='block';
            };
            div1.onmouseout=function (){
                mask.style.display='none';
                div2.style.display='none';
            };

            div1.onmousemove=function (ev){
                let left=ev.offsetX-mask.offsetWidth/2;
                let top=ev.offsetY-mask.offsetHeight/2;

                if(left<0){
                    left=0;
                }
                if(left>div1.offsetWidth-mask.offsetWidth){
                    left=div1.offsetWidth-mask.offsetWidth;
                }

                if(top<0){
                    top=0;
                }
                if(top>div1.offsetHeight-mask.offsetHeight){
                    top=div1.offsetHeight-mask.offsetHeight;
                }

                mask.style.left=left+'px';
                mask.style.top=top+'px';

                // mask.style.left=ev.pageX-div1.offsetLeft-mask.offsetWidth/2+'px';
                // mask.style.top=ev.pageY-div1.offsetTop-mask.offsetHeight/2+'px';

                //蓝=红*黑2/黑1
                let x=left*(img.offsetWidth-div2.offsetWidth)/(div1.offsetWidth-mask.offsetWidth);
                let y=top*(img.offsetHeight-div2.offsetHeight)/(div1.offsetHeight-mask.offsetHeight);

                img.style.left=-x+'px';
                img.style.top=-y+'px';
            };
        </script>
    </body>
</html>
```

### 2、touch

#### 1）基本使用

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title></title>
        <meta name="viewport" content="width=device-width">
        <style media="screen">
            .box {width:200px;height:200px;background:#CCC;position:absolute;}
            body {height:3000px;}
        </style>
    </head>
    <body>
        asdfasdfas
        <div class="box">asdfasdf</div>
        erwerwe
        <script>
            let div=document.querySelector('.box');
            div.ontouchstart=function (ev){
                # 解决页面跟随滚动
                ev.preventDefault();
                let disX=ev.targetTouches[0].clientX-div.offsetLeft;
                let disY=ev.targetTouches[0].clientY-div.offsetTop;
                div.ontouchmove=function (ev){
                    # 解决页面跟随滚动
                    ev.preventDefault();
                    div.style.left=ev.targetTouches[0].clientX-disX+'px';
                    div.style.top=ev.targetTouches[0].clientY-disY+'px';
                };
                div.ontouchend=function (ev){
                    div.ontouchmove=null;
                    div.ontouchend=null;
                };
            };
        </script>
    </body>
</html>
```

> 存在问题：
>
> ①拖动时，有些移动端浏览器会选中页面文字；
>
> ②拖出可视区，页面会跟随滚动，阻止默认行为可以初步解决；
>
> ③本案例停留在单点触摸，不支持多点触摸；

#### 2）touch库封装

##### 基本拖动

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    #wrap{
      width: 200px;
      height: 200px;
      border: 1px solid #aaa;
    }
    .container{
      background-color: #f0f0f0;
    }
  </style>
  
</head>
<body style="height: 3000px;">
  <div id="wrap">
    <div class="container">
      跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧
      跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞
      吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我
      飞吧跟我飞吧跟我飞吧吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞跟我飞吧跟我飞吧跟我飞吧跟
      我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我
      飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟
      我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧吧
    </div>
  </div>
  <script src="touch.js"></script>
  <script>
    new Touch('#wrap')
  </script>
</body>
</html>
```

```js
(function(window,undefined){
  function assert(exp,msg){
    if(!exp){
      throw new Error(msg||'assert error')
    }
  }
  function getRootElement(el){
    assert(el,'没有传入touch根元素')
    if(typeof el=='string'){
      let root_element=document.querySelector(el)
      assert(root_element,'传入的元素不存在')
      return root_element
    }else if(el instanceof HTMLElement){
      return el
    }else{
      assert(false,'请检查传入的根元素')
    }
  }
  
  window.Touch=class Touch{
    constructor(el){
      this.root=getRootElement(el)
      this.container=this.root.children[0]
      assert(this.container,'容器元素不存在')
      this._initEvent()
      // 记录当前页面滚动到的位置，默认为0
      this.position={x:0,y:0}
    }
    destroy(){

    }
    _initEvent(){
      let startX,startY,disX,disY,oldPositon
      // 这三个事件函数：为什么要挂在对象上，以及放在这里的原因
      // 挂在对象上是因为后期方便在destroy方法中进行销毁
      // 放在这里是因为主要在这里使用,代码结构比较清晰
      this.__start=ev=>{
        // 解决页面超过一屏高度时，跟随滚动的问题
        ev.preventDefault()
        startX=ev.targetTouches[0].clientX
        startY=ev.targetTouches[0].clientY
        oldPositon={...this.position}
      }
      this.__move=ev=>{
        disX=ev.targetTouches[0].clientX-startX
        disY=ev.targetTouches[0].clientY-startY
        this.position.x=oldPositon.x+disX
        this.position.y=oldPositon.y+disY
        this.container.style.transform=`
			translate(${this.position.x}px,${this.position.y}px)
		`
      }
      this.__end=ev=>{
        
      }
      this.container.addEventListener('touchstart',this.__start)
      this.container.addEventListener('touchmove',this.__move)
      this.container.addEventListener('touchend',this.__end)
    }
  }
})(window)
```

> 现存问题：
>
> 所有的东西都扔在了__initEvent里--过于庞大
>
> destroy还没实现
>
> 配置选项（默认参数、横向、纵向）
>
> 限制下拉上滑、超出复位
>
> 弹性回弹、卡顿
>
> move监听
>
> 下拉刷新布局 实现move(height=y)  end监听 start监听
>
> 横向banner实现，以及横向拖动时禁用纵向
>
> 事件监听内部this指向

##### 拖动完善

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    *{
      margin: 0;
      padding: 0;
      list-style: none;
    }
    #wrap{
      width: 200px;
      height: 200px;
      border: 1px solid #aaa;
      position: relative;
    }
    .container{
      background-color: #f0f0f0;
    }
    .pull-down{
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 0;
      background-color: red;
      overflow: hidden;
      text-align: center;
    }
    .banner{
      height: 100px;
      background-color: #ccc; 
      overflow: hidden;
    }
    .banner ul{
      width: 400%;
      overflow: hidden;
    }
    .banner li{
      float: left;
      width: 25%;
      height: 100px;
    }
    .banner li:nth-child(1){
      background-color: yellow;
    }
    .banner li:nth-child(2){
      background-color: blue;
    }
    .banner li:nth-child(3){
      background-color: green;
    }
    .banner li:nth-child(4){
      background-color: pink;
    }
  </style>
  
</head>
<body style="height: 3000px;">
  <div id="wrap">
    <div class="container">
      <div class="banner">
        <ul>
          <li>1</li>
          <li>2</li>
          <li>3</li>
          <li>4</li>
        </ul>
      </div>
      跟我飞吧跟我飞吧跟我飞吧跟跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞
      吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞
      吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞
      吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧我飞吧
      跟我飞吧跟我飞吧跟我飞吧跟我飞吧
    </div>
    <div class="pull-down">
      <div class="text">下拉刷新</div>
    </div>
  </div>
  <button id="cancel">取消滚动</button>
  <script src="touch.js"></script>
  <script>
    var scroll1=new Touch('#wrap',{
      scrollX:false,
      start(){
        document.querySelector('.pull-down').style.transition=``
        document.querySelector('.text').style.transition=``
      },
      move(x,y){
        document.querySelector('.pull-down').style.height=y+'px'
        document.querySelector('.text').style.height=y+'px'
        document.querySelector('.text').style.lineHeight=y+'px'
        if(y>40){
          document.querySelector('.text').innerHTML="松手"
        }else{
          document.querySelector('.text').innerHTML="下拉刷新"
        }
      },
      end(x,y){
        document.querySelector('.pull-down').style.transition=`all ${this.options.debounceTime}ms linear`
        document.querySelector('.text').style.transition=`all ${this.options.debounceTime}ms linear`
        document.querySelector('.pull-down').style.height=0+'px'
        document.querySelector('.text').style.height=0+'px'
        document.querySelector('.text').style.lineHeight=0+'px'
      }
    });
    var scroll2=new Touch('.banner',{
      scrollX:true,
      scrollY:false,
      end(){
        let n=Math.round(-this.position.x/200);
        document.querySelector('.banner ul').style.transform=`translateX(-${n*200}px)`;
        this.position.x=-n*200;
      }
    })
    document.getElementById('cancel').onclick=function(){
      scroll1.destroy()
    }
  </script>
</body>
</html>
```

```js
(function(window,undefined){
  function assert(exp,msg){
    if(!exp){
      throw new Error(msg||'assert error')
    }
  }
  function getRootElement(el){
    assert(el,'没有传入touch根元素')
    if(typeof el=='string'){
      let root_element=document.querySelector(el)
      assert(root_element,'传入的元素不存在')
      return root_element
    }else if(el instanceof HTMLElement){
      return el
    }else{
      assert(false,'请检查传入的根元素')
    }
  }
  let defaultOpts={
    scrollX:false,
    scrollY:true,
    pullSpeed:0.2,
    debounceTime:300,
    easing:'linear'
  }
  window.Touch=class Touch{
    constructor(el,opts){
      this.root=getRootElement(el)
      this.container=this.root.children[0]
      assert(this.container,'容器元素不存在')
      this._initEvent()
      this.position={x:0,y:0}
      // 默认参数合并
      this.options=Object.assign({},defaultOpts,opts)
    }
    destroy(){
      // 销毁拖动事件
      this.container.removeEventListener('touchstart',this.__start)
      this.container.removeEventListener('touchmove',this.__move)
      this.container.removeEventListener('touchend',this.__end)
    }
    _initEvent(){
      let startX,startY,disX,disY,oldPositon
      this.__start=ev=>{
        ev.preventDefault()
        // 解决自己拖动触发父级拖动的问题
        ev.cancelBubble=true
        startX=ev.targetTouches[0].clientX
        startY=ev.targetTouches[0].clientY
        oldPositon={...this.position}
        this._doStart()
      }
      this.__move=ev=>{
        // 解决自己拖动触发父级拖动的问题（这里是为了防止冒泡触发这个事件，时找不到oldPositon而报错）
        ev.cancelBubble=true
        disX=ev.targetTouches[0].clientX-startX
        disY=ev.targetTouches[0].clientY-startY
        this.position.x=oldPositon.x+disX
        this.position.y=oldPositon.y+disY
        this._doMove()
      }
      this.__end=ev=>{
        // 解决自己拖动触发父级拖动的问题（这里是为了防止冒泡触发这个事件，时找不到oldPositon而报错）
        ev.cancelBubble=true
        this._doEnd()
      }
      this.container.addEventListener('touchstart',this.__start)
      this.container.addEventListener('touchmove',this.__move)
      this.container.addEventListener('touchend',this.__end)
    }
    _doStart(){
      let {x,y}=this.position
      // 取消回弹过渡效果
      this.container.style.transition=''
      // start时触发外部监听函数
      if(this.options.start){
        assert(typeof this.options.start=='function','要是函数哦')
        this.options.start.call(this,x,y)
      }
    }
    _doMove(){
      let {x,y}=this.position
      // 纵向拖动超出时限制位移速度
      let maxY=this.container.offsetHeight-this.root.offsetHeight
      maxY= maxY<0 ? 0 : maxY
      if(y>0){
        y*=this.options.pullSpeed
      } 
      if(y<-maxY){
        y=-maxY+(y+maxY)*this.options.pullSpeed
      }
      // 横向拖动超出时限制位移速度
      let maxX=this.container.offsetWidth-this.root.offsetWidth
      maxX= maxX<0 ? 0 : maxX
      if(x>0){
        x*=this.options.pullSpeed
      }
      if(x<-maxX){
        x=-maxX+(x+maxX)*this.options.pullSpeed
      }
      // 根据配置参数决定开启哪个方向的拖动
      if(this.options.scrollX&&this.options.scrollY){
        this.container.style.transform=`translate(${x}px,${y}px)`
      }else if(this.options.scrollX){
        (maxX!=0) && (this.container.style.transform=`translateX(${x}px)`)
      }else if(this.options.scrollY){
        (maxY!=0) && (this.container.style.transform=`translateY(${y}px)`)
      }
      // move时触发外部监听函数
      if(this.options.move){
        assert(typeof this.options.move=='function','要是函数哦')
        this.options.move.call(this,x,y)
      }
    }
    _doEnd(){
      let {x,y}=this.position
      // 纵向超出复位
      let maxY=this.container.offsetHeight-this.root.offsetHeight
      if(y<-maxY){
        y=-maxY
      }
      if(y>0){
        y=0
      }
      // 横向超出复位
      let maxX=this.container.offsetWidth-this.root.offsetWidth
      if(x<-maxX){
        x=-maxX
      }
      if(x>0){
        x=0
      }
      // 回弹，并添加动画
      this.container.style.transition=`transform ${this.options.debounceTime}ms ${this.options.easing}`
      if(this.options.scrollX&&this.options.scrollY){
        this.container.style.transform=`translate(${x}px,${y}px)`
      }else if(this.options.scrollX){
        (maxX!=0) && (this.container.style.transform=`translateX(${x}px)`)
      }else if(this.options.scrollY){
        (maxY!=0) && (this.container.style.transform=`translateY(${y}px)`)
      }
      // 更新position
      this.position.x=x
      this.position.y=y
      //end时触发外部监听函数
      if(this.options.end){
        assert(typeof this.options.end=='function','要是函数哦')
        this.options.end.call(this,x,y)
      }
    }
  }
})(window)
```

> 现存问题：
>
> 惯性还没实现
>
> 多点触摸（手势、缩放、旋转）
>
> 内部包含原生事件不能触发（start内部阻止了默认行为，但是又不能不阻止（页面跟滚）-->手动触发事件）

### 3、事件队列

#### 1）触发DOM事件

```html
<button type="button" id="btn1">按钮1</button>
<button type="button" id="btn2">按钮2</button>
<script>
    let btn1=document.querySelector('#btn1');
    let btn2=document.querySelector('#btn2');
	
    class MyEvent extends Event{
        constructor(...args){
            super(...args);
            this.a=12
        }
    }
    
    btn1.addEventListener('click', function (){
        alert('我是内置click事件');
    }, false);
    
    btn1.addEventListener('aaa', function (e){
        alert('我是自定义事件');
        console.log(e.a);#12
    }, false);

    btn2.onclick=function (){
        # btn1.onclick()只能触发行间事件，或DOM1事件
        // btn1.onclick();
        # 下面的方式可以触发所有形式的事件
        // let ev=new Event('click');
        // btn1.dispatchEvent(ev);
        # 派发自定义事件
        // let ev=new Event('aaa');
        // btn1.dispatchEvent(ev);
        # 给自定义事件--定义事件对象
        let ev=new MyEvent('aaa');
        btn1.dispatchEvent(ev);
    };
</script>
```

> 不兼容IE6、7
>
> 事件是DOM功能，原生DON事件存在巨大的缺陷：
>
> 1.性能低
>
> 2.依赖于浏览器，可移植性不高
>
> 所以我们需要自定义自己的一套事件机制

#### 2）事件队列实现

事件队列在框架中的地位非常重要，它的出现使应用中的每个部分在通信的时候极大程度的解除了耦合操作。而且像原生的DOM对象最顶层的基类就是EventTarget-->Node-->Element-->HTMLElement，原因就是HTML中的每个东西都可能用到事件，vue/angular等一些框架也是这样实现的。

事件队列原理：中间层，上游提供者只负责向外界提供指定的事件名称，可以有很多下游使用者来使用这个事件名称，至于下游使用者的具体逻辑则可以自由定义。

##### 基本使用

```js
class Pipe{
    constructor(){
        this.pipes={};
    }
    on(type, fn){
        this.pipes[type]=this.pipes[type]||[];
        if(this.pipes[type].findIndex(func=>func==fn)==-1){
          this.pipes[type].push(fn);
        }
    }
    off(type, fn){
        if(this.pipes[type]){
            this.pipes[type]=this.pipes[type].filter(func=>func!=fn);
            if(this.pipes[type].length==0){
                delete this.pipes[type];
            }
        }
    }
    emit(type, ...args){
        if(this.pipes[type]){
            this.pipes[type].forEach(fn=>{
                fn(...args);
            });
        }
    }
}
```

```html
<button type="button" id="btn1">按钮1</button>
<script>
    const pipe=new Pipe();
    pipe.on('aaa', (a, b)=>{
        alert('sdfasfsda');
        console.log(a, b);
    });
    
    document.querySelector('#btn1').onclick=function (){
        pipe.emit('aaa', 12, 5);
    };
</script>
```

##### 性能测试

```html
<button type="button" id="btn1">按钮1</button>
<script>
    let btn1=document.querySelector('#btn1');
    btn1.addEventListener('aaa', function (ev){ }, false);
    //750
    let start=Date.now();
    for(let i=0;i<100000;i++){
        let ev=new MyEvent('aaa');
        btn1.dispatchEvent(ev);
    }
    console.log(Date.now()-start);
</script>
```

```html
<script>
    let pipe=new Pipe();
    pipe.on('aaa', ()=>{});
    //43
    let start=Date.now();
    for(let i=0;i<100000;i++){
        pipe.emit('aaa');
    }
    console.log(Date.now()-start);
</script>
```

#### 3）事件队列应用

##### 组件间数据同步

```html
<div id="div1"> {{a}} </div>
<div id="div2"> <button type="button">++</button> </div>
<script>
    const $=document.querySelectorAll.bind(document);
    const pipe=new Pipe();
    class Component1{
        constructor(){
            this.a=12;
            this.el=$('#div1')[0];
            this.render();
            pipe.on('add', ()=>{
                this.a++;
                this.render();
            });
        }
        render(){
            this.el.innerHTML=this.a;
        }
    }
    class Component2{
        constructor(){
            this.el=$('#div2')[0];
            this.el.children[0].onclick=()=>{
                pipe.emit('add');
            };
        }
    }
    new Component1();
    new Component2();
</script>
```

> 事件队列的出现使两个组件间在同步数据的时候解除了耦合操作，使我们的程序极易维护

##### touch库完善

```js
(function(window,undefined){
  function assert(exp,msg){
    if(!exp){
      throw new Error(msg||'assert error')
    }
  }
  function getRootElement(el){
    assert(el,'没有传入touch根元素')
    if(typeof el=='string'){
      let root_element=document.querySelector(el)
      assert(root_element,'传入的元素不存在')
      return root_element
    }else if(el instanceof HTMLElement){
      return el
    }else{
      assert(false,'请检查传入的根元素')
    }
  }
  let defaultOpts={
    scrollX:false,
    scrollY:true,
    pullSpeed:0.2,
    debounceTime:300,
    easing:'linear'
  }
  # 继承Pipe
  window.Touch=class Touch extends Pipe{
    constructor(el,opts){
      this.root=getRootElement(el)
      this.container=this.root.children[0]
      assert(this.container,'容器元素不存在')
      this._initEvent()
      this.position={x:0,y:0}
      // 默认参数合并
      this.options=Object.assign({},defaultOpts,opts)
    }
    destroy(){
      // 销毁拖动事件
      this.container.removeEventListener('touchstart',this.__start)
      this.container.removeEventListener('touchmove',this.__move)
      this.container.removeEventListener('touchend',this.__end)
    }
    _initEvent(){
      let startX,startY,disX,disY,oldPositon
      this.__start=ev=>{
        ev.preventDefault()
        // 解决自己拖动触发父级拖动的问题
        ev.cancelBubble=true
        startX=ev.targetTouches[0].clientX
        startY=ev.targetTouches[0].clientY
        oldPositon={...this.position}
        this._doStart()
      }
      this.__move=ev=>{
        // 解决自己拖动触发父级拖动的问题（这里是为了防止冒泡触发这个事件，时找不到oldPositon而报错）
        ev.cancelBubble=true
        disX=ev.targetTouches[0].clientX-startX
        disY=ev.targetTouches[0].clientY-startY
        this.position.x=oldPositon.x+disX
        this.position.y=oldPositon.y+disY
        this._doMove()
      }
      this.__end=ev=>{
        // 解决自己拖动触发父级拖动的问题（这里是为了防止冒泡触发这个事件，时找不到oldPositon而报错）
        ev.cancelBubble=true
        this._doEnd()
      }
      this.container.addEventListener('touchstart',this.__start)
      this.container.addEventListener('touchmove',this.__move)
      this.container.addEventListener('touchend',this.__end)
    }
    _doStart(){
      let {x,y}=this.position
      // 取消回弹过渡效果
      this.container.style.transition=''
      # start时触发外部监听函数
      this.emit('start',x,y);
    }
    _doMove(){
      let {x,y}=this.position
      // 纵向拖动超出时限制位移速度
      let maxY=this.container.offsetHeight-this.root.offsetHeight
      maxY= maxY<0 ? 0 : maxY
      if(y>0){
        y*=this.options.pullSpeed
      } 
      if(y<-maxY){
        y=-maxY+(y+maxY)*this.options.pullSpeed
      }
      // 横向拖动超出时限制位移速度
      let maxX=this.container.offsetWidth-this.root.offsetWidth
      maxX= maxX<0 ? 0 : maxX
      if(x>0){
        x*=this.options.pullSpeed
      }
      if(x<-maxX){
        x=-maxX+(x+maxX)*this.options.pullSpeed
      }
      // 根据配置参数决定开启哪个方向的拖动
      if(this.options.scrollX&&this.options.scrollY){
        this.container.style.transform=`translate(${x}px,${y}px)`
      }else if(this.options.scrollX){
        (maxX!=0) && (this.container.style.transform=`translateX(${x}px)`)
      }else if(this.options.scrollY){
        (maxY!=0) && (this.container.style.transform=`translateY(${y}px)`)
      }
      # move时触发外部监听函数
      this.emit('move', x, y);
    }
    _doEnd(){
      let {x,y}=this.position
      // 纵向超出复位
      let maxY=this.container.offsetHeight-this.root.offsetHeight
      if(y<-maxY){
        y=-maxY
      }
      if(y>0){
        y=0
      }
      // 横向超出复位
      let maxX=this.container.offsetWidth-this.root.offsetWidth
      if(x<-maxX){
        x=-maxX
      }
      if(x>0){
        x=0
      }
      // 回弹，并添加动画
      this.container.style.transition=`transform ${this.options.debounceTime}ms ${this.options.easing}`
      if(this.options.scrollX&&this.options.scrollY){
        this.container.style.transform=`translate(${x}px,${y}px)`
      }else if(this.options.scrollX){
        (maxX!=0) && (this.container.style.transform=`translateX(${x}px)`)
      }else if(this.options.scrollY){
        (maxY!=0) && (this.container.style.transform=`translateY(${y}px)`)
      }
      // 更新position
      this.position.x=x
      this.position.y=y
      # end时触发外部监听函数
	  this.emit('end',x,y);
    }
  }
})(window)
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    *{
      margin: 0;
      padding: 0;
      list-style: none;
    }
    #wrap{
      width: 200px;
      height: 200px;
      border: 1px solid #aaa;
      position: relative;
    }
    .container{
      background-color: #f0f0f0;
    }
    .pull-down{
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 0;
      background-color: red;
      overflow: hidden;
      text-align: center;
    }
  </style>
</head>
<body style="height: 3000px;">
  <div id="wrap">
    <div class="container">
      跟我飞吧跟我飞吧跟我飞吧跟跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞
      吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞
      吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞
      吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧跟我飞吧我飞吧
      跟我飞吧跟我飞吧跟我飞吧跟我飞吧
    </div>
    <div class="pull-down">
      <div class="text">下拉刷新</div>
    </div>
  </div>
  <button id="cancel">取消滚动</button>
  <script src="pipe.js"></script>
  <script src="touch.js"></script>
  <script>
    var scroll=new Touch('#wrap',{
      scrollX:false
    });
    scroll.on('start',function(){
      document.querySelector('.pull-down').style.transition=``
      document.querySelector('.text').style.transition=``
    });
    # 第一次监听，还可以添加其他监听者
    scroll.on('move',function(x,y){
      document.querySelector('.pull-down').style.height=y+'px'
      document.querySelector('.text').style.height=y+'px'
      document.querySelector('.text').style.lineHeight=y+'px'
      if(y>40){
        document.querySelector('.text').innerHTML="松手"
      }else{
        document.querySelector('.text').innerHTML="下拉刷新"
      }
    });
    scroll.on('end',function(){
      let dbtime=scroll.options.debounceTime
      document.querySelector('.pull-down').style.transition=`all ${dbtime}ms linear`
      document.querySelector('.text').style.transition=`all ${dbtime}ms linear`
      document.querySelector('.pull-down').style.height=0+'px'
      document.querySelector('.text').style.height=0+'px'
      document.querySelector('.text').style.lineHeight=0+'px'
    });
  </script>
</body>
</html>
```

> 原来的版本中，对move等的监听只能监听一次，比如想监听两次move,一个实现下拉刷新，一个实现上拉加载更多就不行了。
>
> 而使用了事件队列后，可以对同一个行为添加多个监听，实现对同一个行为不同操作的解耦。

## 第四部分 数据交互

### 1、xhr

兼容性：IE6不支持(可以用ActiveX)，IE7及其以上都支持

缺点：稍微老、复杂

#### 1）基本使用

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title></title>
    </head>
    <body>
        <script>
            let xhr=new XMLHttpRequest();
            xhr.open('get', 'data/1.json', true);
            xhr.send();
            // xhr.onload=function (){
            //   // console.log('完成');
            //   // console.log(xhr.responseXML.getElementsByTagName('name')[0]);
            //   console.log(xhr.responseText);
            // };
            
            // readyState：通信状态
            // 0   初始——刚创建出来
            // 1   已连接
            // 2   已发送
            // 3   已接收-头(header)
            // 4   已接收-内容(body)
            xhr.onreadystatechange=function (){
                if(xhr.readyState==4){  //全完事
                    alert(xhr.status);
                }
            };
            console.log('aaaa');
        </script>
    </body>
</html>
```

#### 2）跨域

Access to XMLHttpRequest at 'file:///C:/javascript/data/1.json' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.

1.标准？
域=协议+域名+端口

http://jd.com/  -> https://jd.com/      跨域
http://jd.com/  -> http://jd.com:8080/  跨域
http://www.jd.com/ -> http://top.jd.com/ 不跨域

2.为什么？
浏览器限制 跨站脚本攻击
let div=document.createElement('div');
div.style.cssText='position:fixed:width:100%;height:100%;';
div.innerHTML='淘宝天下第一';

3）解决方案

- 代理服务器（proxy）
- jsonp
- cors

#### 3）异步同步

Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user's experience. For more help, check https://xhr.spec.whatwg.org/.

异步、同步

- 1.异步函数：setTimeout
- 2.同步函数：alert

- 异步——操作和其他工作同时进行

- 同步——完成前一个、才能开始后一个

异步的优势：

- 1.性能高
- 2.体验好

同步的优势：

- 1.编写程序更简单

用同步的写法，完成异步的操作

- async/await

- js是单线程——js不支持异步操作
  一个任务（一段代码、一个函数）一旦开始不能停，等到结束再开始下一个任务

结论：

- 1.js没有异步
- 2.async/await编译成为一堆promise

#### 4）http协议

##### 版本

- http1.0 rfc-1945
- http1.1 rfc-2616  长连接（keep-alive）
- https   rfc-2818  安全，ssl
- http2.0 rfc-7540  强制加密、头压缩、多路复用、服务端推送

##### 消息结构

- header——头：信息——32K
  - content-type
  - cache-control
  - set-cookie
  - cookies

-   body——体：数据——2G

##### 请求方法

- get   获取数据，请求数据夹在url里
  - aaa.com/query/a?a=12&b=44
  - 数据量小

-   post  发送数据，请求数据夹在body
  - 数据量大    2G
- head  服务器仅仅返回头就行

- put   发送文件

- delete  删除

- patch   修改数据

- options 发送参数

- ...自定义

- RESTful风格

##### 状态码

- 1xx   消息    一般无需处理
- 2xx   成功
- 3xx   重定向
  - 301-永久, 302-临时
  - 304
- 4xx   错误-请求错误
- 5xx   错误-服务器错误
- 6xx   扩展状态码

##### body常用格式

- urlencoded        a=12&b=55&c=99      适合少量数据
- multipart                             适合上传文件
- application/json  json
- application/octet-stream              二进制数据 下载/上传二进制文件

### 2、fetch

兼容性：太新、Edge下的所有IE都不支持，移动端没问题

优点：使用简单

#### 1）基本使用

```js
fetch(url, {
  method: 'post',
  headers: {
    a: 12,
    'content-type': 'application/www-form-urlencoded'
  },
  body: 'a=12&b=5'
  // body: '{"a": 12, "b": 5}'
})
// (async ()=>{
//   let res=await fetch('data/1.json');
//   //接收数据——头
//
//   //开始接收——body
//   let data=await res.json();
//
//   console.log(data);
// })();

// fetch('data/1.json').then(res=>res.json()).then(data=>{
//   console.log(data);
// });

(async ()=>{
    let data=await fetch('data/1.json').then(res=>res.json());
    console.log(data);
})();
```
#### 2）兼容性处理

```js
const defaultOptions={
    method: 'get',
    headers: {},
};
// window.fetch=window.fetch||function (url, options){
window.fetch=function (url, options){
    options=Object.assign({}, defaultOptions, options);
    return new Promise((resolve, reject)=>{
        let xhr=new XMLHttpRequest();
        xhr.open(options.method, url, true);
        xhr.send(options.body);
        xhr.onreadystatechange=function (){
            if(xhr.readyState==3){
                if(xhr.status>=200 && xhr.status<300 || xhr.status==304){
                    resolve(new FetchResponse(xhr))
                }else{
                    reject(xhr);
                }
            }
        };
    });
};
class FetchResponse{
    constructor(xhr){
        this._data=new Promise((resolve, reject)=>{
            xhr.onreadystatechange=function (){
                resolve(xhr);
            };
        });
    }
    json(){
        return new Promise((resolve, reject)=>{
            this.text().then(txt=>{
                try{
                    let json=JSON.parse(txt);
                    resolve(json);
                }catch(e){
                    reject(e);
                }
            });
        });
    }
    text(){
        return new Promise((resolve, reject)=>{
            this._data.then(xhr=>{
                resolve(xhr.responseText);
            });
        });
    }
}
```

#### 3）二进制数据处理

```html
<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title></title>
    </head>
    <body>
        <script>
            (async ()=>{
                let res=await fetch('data/1.png');
                # 应用：防盗链（视频网站拿不到视频）
                let data=await res.blob();
				# 转换成一个临时的blob-url，页面关系该地址失效
                let url=URL.createObjectURL(data);
                let img=document.getElementById('img1');
                img.src=url;
            })();
        </script>
        <img id="img1" />
    </body>
</html>

```

### 3、websocket

理论上兼容到IE10以上浏览器，可以通过一定手段兼容到IE6

#### 1）连接

#### 2）前端ws封装

#### 3）数据传输

### 4、数据解析

#### 1）二进制

##### Blob

资源标识符--性能最高

##### ArrayBuffer

原始二进制数组

##### Int8Array

转换成适合js使用的数据

二进制意义一一性能最高、数据体积最小

##### Base64

使用64进制（6位二进制）：使用所有的可显示字符来表示文件数据，这就是不用8位（256进制的原因）

不太适合网络传输：数据膨胀（1.3333...）带宽浪费,因为要用8位保存原本的6位数据；传输过程中数据会丢失；

适合：本地文件显示，传输小图

##### 简单使用

```html
<input type="file" id="file1">
<img src="" id="img1">
<script>
    let file=document.getElementById('file1');

    file.onchange=function (){
        // let reader=new FileReader();
        // reader.onload=function 
        # ArrayBuffer不方便直接操作，比如获取长度，转换成Uint8Array即有了length属性
        //   let arr=new Uint8Array(this.result);
        //   console.log(arr[0]);
        // };
        # 把读取的文件转换成ArrayBuffer
        // reader.readAsArrayBuffer(file.files[0]);

        # 读取到的文件对象，就是就是继承自blob的一个子类
        // let url=URL.createObjectURL(file.files[0]);
        // document.getElementById('img1').src=url;

        # base64
        let file=document.getElementById('file1');
        file.onchange=function (){
            let reader=new FileReader();
            reader.onload=function (){
                console.log(this.result);
                // document.getElementById('img1').src=this.result;
            };
            reader.readAsDataURL(file.files[0]);
        };
    };
</script>
```

#### 2）视频处理

#### 3）FormData

## 第五部分 图形、动画